<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>张兴亚的技术博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://zxyyee.cn/"/>
  <updated>2019-09-04T11:29:33.769Z</updated>
  <id>https://zxyyee.cn/</id>
  
  <author>
    <name>Xingya</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>个人简历</title>
    <link href="https://zxyyee.cn/post/%E4%B8%AA%E4%BA%BA%E7%AE%80%E5%8E%86.html"/>
    <id>https://zxyyee.cn/post/个人简历.html</id>
    <published>2019-09-01T11:13:24.000Z</published>
    <updated>2019-09-04T11:29:33.769Z</updated>
    
    <content type="html"><![CDATA[<p>张兴亚</p><p>Python全栈开发工程师</p><p>4年工作经验                           </p><p>Tel：155-4652-3383</p><p>Email：<a href="mailto:zhangxingya9@gmail.com" target="_blank" rel="noopener">zhangxingya9@gmail.com</a> </p><p>个人博客：zxyyee.cn</p><hr><h3 id="教育经历"><a href="#教育经历" class="headerlink" title="教育经历"></a>教育经历</h3><p>2011.09-2015.06                  东北林业大学                           统招本科</p><hr><h3 id="个人介绍"><a href="#个人介绍" class="headerlink" title="个人介绍"></a>个人介绍</h3><p>四年Python全栈开发经验，参与设计并开发过多个项目，负责系统核心模块的开发，熟练掌握<strong>各种Python框架</strong>，熟练使用<strong>Docker</strong>，使用<strong>Docker-compose</strong>批量管理容器集群，<strong>Docker-fil</strong>e编写部署脚本，并采用<strong>RollingUpdat</strong>e升级容器。利用<strong>Redisearch</strong>进行全文检索。熟悉前端业务规范，掌握<strong>vue.js</strong>开发，熟悉响应式开发框架<strong>Bootstrap</strong>，<strong>flex弹性布局</strong>，了解<strong>微服务架构</strong>，掌握<strong>RPC</strong>协议，熟练使用<strong>Thrift</strong>框架，对算法和数据结构有独到的见解。有<strong>高并发WEB应用</strong>架构的能力。有利用<strong>mpvue</strong>框架开发微信小程序的经验。具备优秀的学习能力和团队沟通能力，经常与团队进行技术分享，能与团队共同成长。</p><hr><h3 id="专业技能"><a href="#专业技能" class="headerlink" title="专业技能"></a>专业技能</h3><p>后端框架：Tornado，Django，Thrift ，Celery，Sanic，Flask</p><p>前端框架：Node.js，Vue.js，Bootstrap，Mpvue，React</p><p>数据库：Mysql，Mongodb ，Redis</p><p>工具：Docker，Postman，VSCode</p><p>其他：Fastdfs ， Websocket， Quill-Edior，RabbitMQ，SuperVisor</p><hr><h3 id="工作经历"><a href="#工作经历" class="headerlink" title="工作经历"></a>工作经历</h3><p>l  2017年2月 - 至今          百度糯米 — Python高级全栈开发工程师</p><p>l  2015年6月 - 2017年2月 北京医视时代科技发展有限公司 — 初级python开发工程师</p><hr><h3 id="项目经验"><a href="#项目经验" class="headerlink" title="项目经验"></a>项目经验</h3><h4 id="美食团购"><a href="#美食团购" class="headerlink" title="美食团购"></a>美食团购</h4><p>*<em>项目描述: *</em></p><p>B2C网站，通过线上中介的方式，将商家和用户联系起来。团购网站与商家合作，签订一定人数规模的顾客和一定的商家折扣。在线预订、在线支付。根据客户对商家环境或食品质量等的评价，对每个商家进行分数评估。</p><p>项目职责：支付模块、情感分析、技术优化、运维工作</p><p><strong>技术要点：</strong></p><p>•  项目的大规模服务采用 <strong>Docker</strong> 进行部署，隔离服务；项目采用使用 Mysql 数据库存储数据，配置<strong>主从同步</strong>，缓解数据库压力。</p><p>•      采用<strong>Celery</strong>和<strong>Rabbitmq</strong>异步任务队列架构，同时配置自动化定时任务</p><p>•   利用<strong>gensim</strong> 对商家评论进行分析，区分正反面评价。进行商家分数评估。</p><p>•   使用 <strong>Redis</strong> 搭建集群，解决高并发。</p><p>•   利用 <strong>Websocket</strong> 实现实时消息推送。</p><p>•   三方支付使用在线支付接口，封装支付宝，微信等第三方支付平台。</p><p>•   后期使用 <strong>Thrift</strong> 框架 <strong>RPC</strong> 协议架构对传统的 http 接口进行重构，提高了整体接口的<strong>性能和吞吐量</strong>。</p><p>•      利用 <strong>Nginx</strong> 反向代理后台<strong>Tornado</strong>接口，并且针对性使用 Nginx <strong>负载均衡</strong>策略。</p><p>•      使用<strong>Supervisor</strong>来监控服务器进程，自动回复进程，简化服务操作。<strong>降低了日常维护成本</strong>。</p><h4 id="管理信息系统"><a href="#管理信息系统" class="headerlink" title="管理信息系统"></a>管理信息系统</h4><p><strong>项目描述：</strong></p><p>公司内部使用的管理系统，针对员工的管理系统，规范流程，随时监控流程进度，减少了人为的失误，使信息安全得到保障。项目模块：流程协作类管理，人事行政类管理。</p><p><strong>项目职责</strong>：</p><p>流程协作类管理：流程审批、费用管理、任务管理   </p><p>人事行政类管理：考勤管理、假期管理</p><p><strong>技术要点：</strong></p><p>• 集成<strong>RBAC</strong>权限管理系统，方便管理层权限管理及责任划分。</p><p>• 搭建基于<strong>Task</strong> 的任务计划管理， 对计划任务进行配置和管理。</p><p>• 构建假期管理， 随时了解办理进度，让出差、请假申请过程变得可控，同时关联人事考勤。</p><p>• 采用<strong>Bootstrap</strong>响应式设计前端框架，方便领导随时审批和查看平台状况。</p><p>####<strong>医学知识库</strong> </p><p><strong>项目详情：</strong></p><p>医学知识库是集医学数据库群、医学图书库、医学图片库以及教学资源库等医学资源于一体，是一套庞大的医学类知识库系统。主要功能：医学数据库群、医学图书库、医学图片库，评论回复等模块。</p><p>项目职责：评论回复、精准搜索推荐、数据存储，消息推送</p><p><strong>技术要点：</strong></p><p>•  利用<strong>Websocket</strong>实现后端消息主动推送，改造前端传统轮询技术框架，减少网络请求数，节约可用带宽。</p><p>•  利用<strong>fastdfs</strong>对几十万医学图片静态资源进行去重存储。</p><p>•  利用ElasticSearch进行知识搜索,后续维护时因其运行时内存有着最低限额，改用<strong>Redisearch</strong>打造全文检索引擎。</p><p>•  使用<strong>协同过滤算法</strong>实现精准推荐，人性化推荐，提高用户体验。</p><p>•  通过 <strong>Echart</strong> 实现数据可视化。</p><p>•  通过<strong>Supervisor</strong> 管理服务进程。</p><hr><h3 id="兴趣与奖项"><a href="#兴趣与奖项" class="headerlink" title="兴趣与奖项"></a>兴趣与奖项</h3><p>大学期间参加辩论赛担任三辩，进入半决赛。</p><p>大学期间获得全国计算机竞赛二等奖。</p><p>活跃在各种技术论坛，热衷解决问题和探索。</p><p>代表公司受邀参加百度开发者大会学习和交流。</p>]]></content>
    
    <summary type="html">
    
      个人简历
    
    </summary>
    
      <category term="个人简历" scheme="https://zxyyee.cn/categories/%E4%B8%AA%E4%BA%BA%E7%AE%80%E5%8E%86/"/>
    
    
  </entry>
  
  <entry>
    <title>vue打包cookie失效</title>
    <link href="https://zxyyee.cn/post/vue%E6%89%93%E5%8C%85cookie%E5%A4%B1%E6%95%88.html"/>
    <id>https://zxyyee.cn/post/vue打包cookie失效.html</id>
    <published>2019-08-27T18:13:24.000Z</published>
    <updated>2019-09-04T11:29:15.101Z</updated>
    
    <content type="html"><![CDATA[<h3 id="vue打包cookie失效"><a href="#vue打包cookie失效" class="headerlink" title="vue打包cookie失效"></a>vue打包cookie失效</h3><p>​    在写vue时，购物车等功能用到了js.cookie模块。dist打包之后发现cookie失效。</p><p>将所有js.cookie改成Local Storage之后，问题解决。</p><p>​    别忘了存Local Storage的时候，要将内容json.stringify一下。</p>]]></content>
    
    <summary type="html">
    
      js.cookie失效导致浪费了很多时间
    
    </summary>
    
      <category term="Vue" scheme="https://zxyyee.cn/categories/Vue/"/>
    
    
      <category term="Vue" scheme="https://zxyyee.cn/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>docker-compose及安装</title>
    <link href="https://zxyyee.cn/post/docker-compose.html"/>
    <id>https://zxyyee.cn/post/docker-compose.html</id>
    <published>2019-07-17T17:13:24.000Z</published>
    <updated>2019-09-04T11:28:43.338Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Docker-Compose简介"><a href="#Docker-Compose简介" class="headerlink" title="Docker-Compose简介"></a>Docker-Compose简介</h3><p>Docker-Compose项目是Docker官方的开源项目，负责实现对Docker容器集群的快速编排。 Docker-Compose将所管理的容器分为三层，分别是工程（project），服务（service）以及容器（container）。Docker-Compose运行目录下的所有文件（docker-compose.yml，extends文件或环境变量文件等）组成一个工程，若无特殊指定工程名即为当前目录名。一个工程当中可包含多个服务，每个服务中定义了容器运行的镜像，参数，依赖。一个服务当中可包括多个容器实例，Docker-Compose并没有解决负载均衡的问题，因此需要借助其它工具实现服务发现及负载均衡。 Docker-Compose的工程配置文件默认为docker-compose.yml，可通过环境变量COMPOSE_FILE或-f参数自定义配置文件，其定义了多个有依赖关系的服务及每个服务运行的容器。 使用一个Dockerfile模板文件，可以让用户很方便的定义一个单独的应用容器。在工作中，经常会碰到需要多个容器相互配合来完成某项任务的情况。例如要实现一个Web项目，除了Web服务容器本身，往往还需要再加上后端的数据库服务容器，甚至还包括负载均衡容器等。 Compose允许用户通过一个单独的docker-compose.yml模板文件（YAML 格式）来定义一组相关联的应用容器为一个项目（project）。 Docker-Compose项目由Python编写，调用Docker服务提供的API来对容器进行管理。因此，只要所操作的平台支持Docker API，就可以在其上利用Compose来进行编排管理。 </p><h3 id="Docker-Compose安装"><a href="#Docker-Compose安装" class="headerlink" title="Docker-Compose安装"></a>Docker-Compose安装</h3><p>下面安装docker-compose，运行下面的脚本可以自动安装，并且授权</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo curl -L https://github.com/docker/compose/releases/download/1.21.2/docker-compose-$(uname -s)-$(uname -m) -o /usr/local/bin/docker-compose</span><br><span class="line">sudo chmod +x /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure><p>安装成功后，检查版本号</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose -v</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      docker-compose
    
    </summary>
    
      <category term="Docker" scheme="https://zxyyee.cn/categories/Docker/"/>
    
    
      <category term="Docker" scheme="https://zxyyee.cn/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Redisearch实现全文检索</title>
    <link href="https://zxyyee.cn/post/Redisearch.html"/>
    <id>https://zxyyee.cn/post/Redisearch.html</id>
    <published>2019-05-11T08:13:24.000Z</published>
    <updated>2019-09-04T11:27:57.894Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用Redisearch实现的全文检索功能服务"><a href="#使用Redisearch实现的全文检索功能服务" class="headerlink" title="使用Redisearch实现的全文检索功能服务"></a>使用Redisearch实现的全文检索功能服务</h1><p>​    </p><p>​    首先，安装Rediseach,记住一点你本地的redis服务版本必须在4.0以上，网上一大堆编译安装的攻略，繁琐又浪费时间，所以又到了Docker登场时间了，hub上有编译好的免费镜像供我们下载</p><p>​    </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull redislabs/redisearch</span><br></pre></td></tr></table></figure><p>​    下载后，直接在后台启动服务</p><p>​    </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 6666:6379 redislabs/redisearch:latest</span><br></pre></td></tr></table></figure><p>​    此时已经有一个docker容器在后台启动了，redis服务映射到了宿主的6666端口，我们来连接一下</p><p>​    </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -h localhost -p 6666</span><br></pre></td></tr></table></figure><p>​    </p><p>​    检查 modules 是否成功加载</p><p>​    </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">localhost:6666&gt; MODULE list</span><br><span class="line">1) 1) &quot;name&quot;</span><br><span class="line">   2) &quot;ft&quot;</span><br><span class="line">   3) &quot;ver&quot;</span><br><span class="line">   4) (integer) 10405</span><br></pre></td></tr></table></figure><p>​    如果返回数组中存在 “ft” ， 则表明 redisearch 已经成功加载。</p><p>​    Redisearch 的索引概念 与elasticsearch 的 index 类似，表示某一类文档资源单元。<br>    这里我们定义了一个 SMARTX_VM 索引，其中存储的文档 包含 了 title 和 desc 两个 类型为 TEXT 的field。</p><p>​    </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FT.CREATE SMARTX_VM SCHEMA title TEXT WEIGHT 5.0 desc TEXT</span><br></pre></td></tr></table></figure><p>​    然后向刚刚创建的这条索引加一个文档</p><p>​    </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FT.ADD SMARTX_VM vm-2019082911110001 1.0 LANGUAGE &quot;chinese&quot; FIELDS title &quot;人工智能&quot; desc &quot;我在北京昌平学习人工智能&quot;</span><br></pre></td></tr></table></figure><p>​    LANGUAGE “chinese” 参数 表示 使用 中文分词器 处理文本。默认为英文</p><p>​    此时我们进行文档检索</p><p>​    </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FT.SEARCH SMARTX_VM &quot;人工智能&quot; LANGUAGE &quot;chinese&quot;</span><br></pre></td></tr></table></figure><p>​    注意检索的时候也要指定语言，这里我们用中文分词，默认的英文分词是无法检索中文的</p><p>​    在使用的过程中，发现在命令行进入redis-cli之后，无法对汉字进行编译，所以选择在可视化工具RedisDesktopManager中打开命令行，就可以解决这个问题了。</p>]]></content>
    
    <summary type="html">
    
      Redisearch的配置
    
    </summary>
    
      <category term="Redis" scheme="https://zxyyee.cn/categories/Redis/"/>
    
    
      <category term="Redis" scheme="https://zxyyee.cn/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>nginx反向代理tornado遇到的小问题</title>
    <link href="https://zxyyee.cn/post/nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86tornado%E9%81%87%E5%88%B0%E7%9A%84%E5%B0%8F%E9%97%AE%E9%A2%98.html"/>
    <id>https://zxyyee.cn/post/nginx反向代理tornado遇到的小问题.html</id>
    <published>2019-02-28T11:13:24.000Z</published>
    <updated>2019-09-04T11:28:15.583Z</updated>
    
    <content type="html"><![CDATA[<h3 id="websocket无法正常通信"><a href="#websocket无法正常通信" class="headerlink" title="websocket无法正常通信"></a>websocket无法正常通信</h3><p>​    在项目中运用了websocket进行实时通信，在nginx代理之后，前端请求的端口都是代理之后的端口，websocket的端口也改了。导致无法实时通信。</p><p>​    由于websocket和普通接口的通信协议不同，所以不能请求代理端口。需要正常请求原来的接口。</p>]]></content>
    
    <summary type="html">
    
      nginx反向代理tornado遇到的小问题
    
    </summary>
    
      <category term="nginx" scheme="https://zxyyee.cn/categories/nginx/"/>
    
    
      <category term="nginx" scheme="https://zxyyee.cn/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>session,cookie,sessionStorage,localStorage</title>
    <link href="https://zxyyee.cn/post/session,cookie,Storage.html"/>
    <id>https://zxyyee.cn/post/session,cookie,Storage.html</id>
    <published>2018-07-21T11:13:24.000Z</published>
    <updated>2019-09-04T11:29:10.055Z</updated>
    
    <content type="html"><![CDATA[<p>客户端状态保持是一个老生常谈的问题了，归根结底追踪浏览器的用户身份及其相关数据无非就是以下四种方式：session,cookie,sessionStorage,localStorage</p><p>​    首先cookie和session:</p><p>​    Cookie机制：如果不在浏览器中设置过期时间，cookie被保存在内存中，生命周期随浏览器的关闭而结束，这种cookie简称会话cookie。如果在浏览器中设置了cookie的过期时间，cookie被保存在硬盘中，关闭浏览器后，cookie数据仍然存在，直到过期时间结束才消失。<br>    Cookie是服务器发给客户端的特殊信息，cookie是以文本的方式保存在客户端，每次请求时都带上它<br>    Session机制：当服务器收到请求需要创建session对象时，首先会检查客户端请求中是否包含sessionid。如果有sessionid，服务器将根据该id返回对应session对象。如果客户端请求中没有sessionid，服务器会创建新的session对象，并把sessionid在本次响应中返回给客户端。通常使用cookie方式存储sessionid到客户端，在交互中浏览器按照规则将sessionid发送给服务器。如果用户禁用cookie，则要使用URL重写，可以通过response.encodeURL(url) 进行实现；API对encodeURL的结束为，当浏览器支持Cookie时，url不做任何处理；当浏览器不支持Cookie的时候，将会重写URL将SessionID拼接到访问地址后。<br>    3、存储内容：cookie只能保存字符串类型，以文本的方式；session通过类似与Hashtable的数据结构来保存，能支持任何类型的对象(session中可含有多个对象)<br>    4、存储的大小：cookie：单个cookie保存的数据不能超过4kb；session大小没有限制。<br>    5、安全性：cookie：针对cookie所存在的攻击：Cookie欺骗，Cookie截获；session的安全性大于cookie。<br>    原因如下：<br>    （1）sessionID存储在cookie中，若要攻破session首先要攻破cookie；<br>    （2）sessionID是要有人登录，或者启动session_start才会有，所以攻破cookie也不一定能得到sessionID；<br>    （3）第二次启动session_start后，前一次的sessionID就是失效了，session过期后，sessionID也随之失效。<br>    （4）sessionID是加密的<br>    （5）综上所述，攻击者必须在短时间内攻破加密的sessionID，并非易事。<br>    6、应用场景：<br>    cookie：<br>    （1）判断用户是否登陆过网站，以便下次登录时能够实现自动登录（或者记住密码）。如果我们删除cookie，则每次登录必须从新填写登录的相关信息。<br>    （2）保存上次登录的时间等信息。<br>    （3）保存上次查看的页面<br>    （4）浏览计数<br>    session：Session用于保存每个用户的专用信息，变量的值保存在服务器端，通过SessionID来区分不同的客户。<br>    （1）网上商城中的购物车<br>    （2）保存用户登录信息<br>    （3）将某些数据放入session中，供同一用户的不同页面使用<br>    （4）防止用户非法登录<br>    7、缺点：cookie：<br>    （1）大小受限<br>    （2）用户可以操作（禁用）cookie，使功能受限<br>    （3）安全性较低<br>    （4）有些状态不可能保存在客户端。<br>    （5）每次访问都要传送cookie给服务器，浪费带宽。<br>    （6）cookie数据有路径（path）的概念，可以限制cookie只属于某个路径下。<br>    session：<br>    （1）Session保存的东西越多，就越占用服务器内存，对于用户在线人数较多的网站，服务器的内存压力会比较大。<br>    （2）依赖于cookie（sessionID保存在cookie），如果禁用cookie，则要使用URL重写，不安全<br>    （3）创建Session变量有很大的随意性，可随时调用，不需要开发者做精确地处理，所以，过度使用session变量将会导致代码不可读而且不好维护。</p><p>​    说白了，这两种状态保持方式都差强人意，于是webStroage应运而生</p><p>​    WebStorage的目的是克服由cookie所带来的一些限制，当数据需要被严格控制在客户端时，不需要持续的将数据发回服务器。<br>    WebStorage两个主要目标：（1）提供一种在cookie之外存储会话数据的路径。（2）提供一种存储大量可以跨会话存在的数据的机制。<br>    HTML5的WebStorage提供了两种API：localStorage（本地存储）和sessionStorage（会话存储）。<br>    1、生命周期：localStorage:localStorage的生命周期是永久的，关闭页面或浏览器之后localStorage中的数据也不会消失。localStorage除非主动删除数据，否则数据永远不会消失。<br>    sessionStorage的生命周期是在仅在当前会话下有效。sessionStorage引入了一个“浏览器窗口”的概念，sessionStorage是在同源的窗口中始终存在的数据。只要这个浏览器窗口没有关闭，即使刷新页面或者进入同源另一个页面，数据依然存在。但是sessionStorage在关闭了浏览器窗口后就会被销毁。同时独立的打开同一个窗口同一个页面，sessionStorage也是不一样的。<br>    2、存储大小：localStorage和sessionStorage的存储数据大小一般都是：5MB<br>    3、存储位置：localStorage和sessionStorage都保存在客户端，不与服务器进行交互通信。<br>    4、存储内容类型：localStorage和sessionStorage只能存储字符串类型，对于复杂的对象可以使用ECMAScript提供的JSON对象的stringify和parse来处理<br>    5、获取方式：localStorage：window.localStorage;；sessionStorage：window.sessionStorage;。<br>    6、应用场景：localStoragese：常用于长期登录（+判断用户是否已登录），适合长期保存在本地的数据（令牌）。sessionStorage：敏感账号一次性登录；<br>    WebStorage的优点：<br>    （1）存储空间更大：cookie为4KB，而WebStorage是5MB；<br>    （2）节省网络流量：WebStorage不会传送到服务器，存储在本地的数据可以直接获取，也不会像cookie一样美词请求都会传送到服务器，所以减少了客户端和服务器端的交互，节省了网络流量；<br>    （3）对于那种只需要在用户浏览一组页面期间保存而关闭浏览器后就可以丢弃的数据，sessionStorage会非常方便；<br>    （4）快速显示：有的数据存储在WebStorage上，再加上浏览器本身的缓存。获取数据时可以从本地获取会比从服务器端获取快得多，所以速度更快；<br>    （5）安全性：WebStorage不会随着HTTP header发送到服务器端，所以安全性相对于cookie来说比较高一些，不会担心截获，但是仍然存在伪造问题；<br>    （6）WebStorage提供了一些方法，数据操作比cookie方便；<br>            setItem (key, value) —— 保存数据，以键值对的方式储存信息。</p>]]></content>
    
    <summary type="html">
    
      session,cookie
    
    </summary>
    
      <category term="cookie" scheme="https://zxyyee.cn/categories/cookie/"/>
    
    
      <category term="cookie" scheme="https://zxyyee.cn/tags/cookie/"/>
    
  </entry>
  
  <entry>
    <title>django自定义过滤器</title>
    <link href="https://zxyyee.cn/post/django%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BF%87%E6%BB%A4%E5%99%A8.html"/>
    <id>https://zxyyee.cn/post/django自定义过滤器.html</id>
    <published>2018-05-28T23:40:07.000Z</published>
    <updated>2019-09-04T11:28:49.702Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Django提供的过滤器和标签"><a href="#Django提供的过滤器和标签" class="headerlink" title="Django提供的过滤器和标签."></a>Django提供的过滤器和标签.</h4><p>例如：upper（转化为大写字母）</p><pre><code>lower（转化为小写字母）autoescape(自动转义)block（模板继承）csrf_token（防止跨站伪造请求）extends（模板继承）filter（过滤器）   等……</code></pre><h4 id="自定义过滤器"><a href="#自定义过滤器" class="headerlink" title="自定义过滤器"></a>自定义过滤器</h4><p>1.新建一个项目，建立一个app， 配置templates 添加html文件，配置static，添加需要的静态文件</p><p>配置views.py urls.py  ,然后启动服务器，保证项目的正常建立与运行，这里不多赘述</p><p>2.在app下创建templatetags文件夹  在文件夹内添加<strong>init</strong>.py  表明我们这是一个可引用的包</p><p>再创建一个myfilter.py 声明我们的自定义过滤器，代码如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.template <span class="keyword">import</span> Library</span><br><span class="line"></span><br><span class="line">register=Library()</span><br><span class="line"></span><br><span class="line"><span class="meta">@register.filter</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(value)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> value+<span class="string">'that is nothing'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@register.filter   #注册过滤器</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">change_length</span><span class="params">(value)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> len(value)&gt;<span class="number">5</span>:</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> value[<span class="number">0</span>:<span class="number">5</span>]+<span class="string">'...'</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line"></span><br><span class="line"><span class="meta">@register.simple_tag  #注册标签</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mytag</span><span class="params">(value1,value2)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> value1==<span class="string">'a'</span>:</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'百度'</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> value2==<span class="string">'b'</span>:</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'&lt;h1&gt;一下&lt;/h1&gt;'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"><span class="meta">@register.simple_tag</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_current_time</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line">    time=datetime.datetime.now()</span><br><span class="line"></span><br><span class="line">    time=time.strftime(<span class="string">'%Y-%m-%d %h:%M:%s'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'&lt;h1&gt;&#123;&#125;&lt;/h1&gt;'</span>.format(time)</span><br></pre></td></tr></table></figure><p>使用时在模板调用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在模板中调用</span><br><span class="line">&#123;% load my_filter %&#125;</span><br><span class="line">&#123;&#123;name|my_str&#125;&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      Django
    
    </summary>
    
      <category term="Django" scheme="https://zxyyee.cn/categories/Django/"/>
    
    
      <category term="Django" scheme="https://zxyyee.cn/tags/Django/"/>
    
  </entry>
  
  <entry>
    <title>支付宝支付</title>
    <link href="https://zxyyee.cn/post/%E6%94%AF%E4%BB%98%E5%AE%9D%E6%94%AF%E4%BB%98.html"/>
    <id>https://zxyyee.cn/post/支付宝支付.html</id>
    <published>2018-05-28T15:13:34.000Z</published>
    <updated>2019-09-04T11:29:57.867Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一步：创建应用"><a href="#第一步：创建应用" class="headerlink" title="第一步：创建应用"></a><strong>第一步：创建应用</strong></h1><p>要在您的应用中接入电脑网站支付能力，您需要登录支付宝开放平台（<a href="https://open.alipay.com/" target="_blank" rel="noopener">open.alipay.com</a>），在开发者中心中创建您的应用，应用审核通过后会生成应用唯一标识（APPID），并且可以申请开通开放产品使用权限。通过 APPID 您的应用才能调用开放产品的接口能力。需要详细了解开放平台创建应用步骤请参考<a href="https://docs.open.alipay.com/200/105310" target="_blank" rel="noopener">《开放平台应用创建指南》</a>。</p><h1 id="第二步：配置应用"><a href="#第二步：配置应用" class="headerlink" title="第二步：配置应用"></a>第二步：配置应用</h1><h2 id="添加功能并签约"><a href="#添加功能并签约" class="headerlink" title="添加功能并签约"></a>添加功能并签约</h2><p>应用创建完成后，系统会自动跳转到应用详情页面。开发者可以在 <strong>功能列表</strong> 中点击 <strong>添加功能</strong> 来添加电脑网站支付功能。待应用上线后，您可以给添加的功能进行签约。电脑网站支付功能支持两种签约方式：<a href="https://b.alipay.com/signing/productDetail.htm?productId=I1011000290000001000" target="_blank" rel="noopener">商家中心</a>签约和应用详情的功能列表处签约（如下图所示）。<br>详细步骤步骤可以参考<a href="https://docs.open.alipay.com/200/105310#s3" target="_blank" rel="noopener">添加应用功能</a>，第三方应用可以代替商户签约。<br><img src="https://gw.alipayobjects.com/zos/skylark-tools/public/files/4a65a87cd5ba99bc06984b2bee19ede8.png" alt="img"></p><h2 id="配置密钥"><a href="#配置密钥" class="headerlink" title="配置密钥"></a>配置密钥</h2><p>为了保证交易双方（商户和支付宝）的身份和数据安全，开发者在调用接口前，需要配置双方密钥，对交易数据进行双方校验。密钥包含应用私钥（APP_PRIVATE_KEY）和应用公钥（APP_PUBLIC_KEY）。生成密钥后，开发者需要在开放平台开发者中心进行密钥配置，配置完成后可以获取支付宝公钥（ALIPAY_PUBLIC_KEY），配置的详细步骤请参考《<a href="https://docs.open.alipay.com/291/105971" target="_blank" rel="noopener">配置应用环境</a>》。您还可以通过观看<a href="https://docs.open.alipay.com/291/106103/" target="_blank" rel="noopener">快速签名教程</a>学习密钥的配置。</p><p><strong>说明</strong>：<br>支付宝开放平台 SDK 封装了签名和验签过程，只需配置账号及密钥参数，建议开发者使用。开发者还可以通过<a href="https://docs.open.alipay.com/200/106122" target="_blank" rel="noopener">自助排查流程</a>和<a href="https://docs.open.alipay.com/200/106120" target="_blank" rel="noopener">验签教程</a>自助排查配置应用过程中遇到的问题。</p><h1 id="第三步：集成并配置-SDK"><a href="#第三步：集成并配置-SDK" class="headerlink" title="第三步：集成并配置 SDK"></a><strong>第三步：集成并配置 SDK</strong></h1><p>要接入电脑网站支付，开发者需要集成服务端 SDK。服务端 SDK 需要商户集成在自己的服务端系统中，用于后续的服务端接口调用。</p><h2 id="下载服务端-SDK"><a href="#下载服务端-SDK" class="headerlink" title="下载服务端 SDK"></a><strong>下载服务端 SDK</strong></h2><p>**<br>为了帮助开发者调用开放接口，我们提供了<a href="https://docs.open.alipay.com/54/103419" target="_blank" rel="noopener">开放平台服务端 SDK</a>，包含 JAVA、PHP、NodeJS、Python 和 .NET 五种，封装了签名&amp;验签、HTTP 接口请求等基础功能。请先下载对应语言版本的 SDK 并引入您的开发工程。</p><h2 id="接口调用配置"><a href="#接口调用配置" class="headerlink" title="接口调用配置"></a><strong>接口调用配置</strong></h2><p>在 SDK 调用前需要进行初始化，以 JAVA 代码为例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AlipayClient alipayClient = new DefaultAlipayClient(URL,APP_ID,APP_PRIVATE_KEY,FORMAT,CHARSET,ALIPAY_PUBLIC_KEY,SIGN_TYPE);</span><br></pre></td></tr></table></figure><p>关键参数说明:</p><table><thead><tr><th>配置参数</th><th>示例值解释</th><th>获取方式/示例值</th></tr></thead><tbody><tr><td>URL</td><td>支付宝网关（固定）</td><td><a href="https://openapi.alipay.com/gateway.do" target="_blank" rel="noopener">https://openapi.alipay.com/gateway.do</a></td></tr><tr><td>APPID</td><td>APPID 即创建应用后生成</td><td>获取见上方<a href="https://docs.open.alipay.com/#s0" target="_blank" rel="noopener">创建应用</a></td></tr><tr><td>APP_PRIVATE_KEY</td><td>开发者私钥，由开发者自己生成</td><td>获取见<a href="https://docs.open.alipay.com/291/105971" target="_blank" rel="noopener">配置密钥</a></td></tr><tr><td>FORMAT</td><td>参数返回格式，只支持 json</td><td>json（固定）</td></tr><tr><td>CHARSET</td><td>编码集，支持 GBK/UTF-8</td><td>开发者根据实际工程编码配置</td></tr><tr><td>ALIPAY_PUBLIC_KEY</td><td>支付宝公钥，由支付宝生成</td><td>获取详见<a href="https://docs.open.alipay.com/291/105971" target="_blank" rel="noopener">配置密钥</a></td></tr><tr><td>SIGN_TYPE</td><td>商户生成签名字符串所使用的签名算法类型，目前支持 RSA2 和 RSA，推荐使用 RSA2</td><td>RSA2</td></tr></tbody></table><p>接下来，就可以用 alipayClient 来调用具体的 API 了。alipayClient 只需要初始化一次，后续调用不同的 API 都可以使用同一个 alipayClient 对象。</p><p><strong>注意：</strong><br>ISV /开发者可以通过<a href="https://docs.alipay.com/isv/10467/xldcyq" target="_blank" rel="noopener">第三方应用授权</a>得到商户授权令牌（app_auth_token）作为请求参数传入，实现代商户发起请求的能力。</p><h1 id="第四步：接口调用"><a href="#第四步：接口调用" class="headerlink" title="第四步：接口调用"></a><strong>第四步：接口调用</strong></h1><h2 id="支付"><a href="#支付" class="headerlink" title="支付"></a>支付</h2><p>电脑网站支付的支付接口 <a href="https://docs.open.alipay.com/api_1/alipay.trade.page.pay" target="_blank" rel="noopener">alipay.trade.page.pay</a> 调用时序图如下：<br><img src="https://gw.alipayobjects.com/os/skylark-tools/public/files/0ba3e82ad37ecf8649ee4219cfe9d16b.png%26originHeight%3D2023%26originWidth%3D2815%26size%3D526149%26status%3Ddone%26width%3D2815" alt="电脑网站支付.png"></p><p>调用顺序如下：</p><ol><li>商户系统请求支付宝接口 <a href="https://docs.open.alipay.com/api_1/alipay.trade.page.pay" target="_blank" rel="noopener">alipay.trade.page.pay</a>，支付宝对商户请求参数进行校验，而后重新定向至用户登录页面。</li><li>用户确认支付后，支付宝通过 get 请求 returnUrl（商户入参传入），返回同步返回参数。</li><li>交易成功后，支付宝通过 post 请求 notifyUrl（商户入参传入），返回异步通知参数。</li><li>若由于网络等问题异步通知没有到达，商户可自行调用交易查询接口 <a href="https://docs.open.alipay.com/api_1/alipay.trade.page.pay" target="_blank" rel="noopener">alipay.trade.query</a> 进行查询，根据查询接口获取交易以及支付信息（商户也可以直接调用查询接口，不需要依赖异步通知）。</li></ol>]]></content>
    
    <summary type="html">
    
      支付宝完成第三方支付
    
    </summary>
    
      <category term="第三方支付" scheme="https://zxyyee.cn/categories/%E7%AC%AC%E4%B8%89%E6%96%B9%E6%94%AF%E4%BB%98/"/>
    
    
      <category term="第三方支付" scheme="https://zxyyee.cn/tags/%E7%AC%AC%E4%B8%89%E6%96%B9%E6%94%AF%E4%BB%98/"/>
    
  </entry>
  
  <entry>
    <title>支付宝退款</title>
    <link href="https://zxyyee.cn/post/%E6%94%AF%E4%BB%98%E5%AE%9D%E9%80%80%E6%AC%BE.html"/>
    <id>https://zxyyee.cn/post/支付宝退款.html</id>
    <published>2018-05-28T11:13:24.000Z</published>
    <updated>2019-09-04T11:29:50.409Z</updated>
    
    <content type="html"><![CDATA[<p>那么根据支付宝的官方文档：<a href="https://docs.open.alipay.com/api_1/alipay.trade.refund" target="_blank" rel="noopener">https://docs.open.alipay.com/api_1/alipay.trade.refund</a></p><p>   从文档中可知，out_trade_no(支付订单号)，refund_amount(退款金额)，这两个参数是必须要传的，所以打开之前写好的pay.py文件，新增退款方法：    </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#请求支付宝退款接口</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">api_alipay_trade_refund</span><span class="params">(self, refund_amount, out_trade_no=None, trade_no=None, **kwargs)</span>:</span></span><br><span class="line">        biz_content = &#123;</span><br><span class="line">            <span class="string">"refund_amount"</span>: refund_amount</span><br><span class="line">        &#125;</span><br><span class="line">        biz_content.update(**kwargs)</span><br><span class="line">        <span class="keyword">if</span> out_trade_no:</span><br><span class="line">            biz_content[<span class="string">"out_trade_no"</span>] = out_trade_no</span><br><span class="line">        <span class="keyword">if</span> trade_no:</span><br><span class="line">            biz_content[<span class="string">"trade_no"</span>] = trade_no</span><br><span class="line">        data = self.build_body(<span class="string">"alipay.trade.refund"</span>, biz_content)</span><br><span class="line">        url = self.__gateway + <span class="string">"?"</span> + self.sign_data(data)</span><br><span class="line">        r = requests.get(url)</span><br><span class="line">        html = r.content.decode(<span class="string">"utf-8"</span>)</span><br><span class="line">        <span class="keyword">return</span> html</span><br></pre></td></tr></table></figure><p>然后在Django的视图方法中加一个退款视图</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">refund</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="comment">#实例化支付类</span></span><br><span class="line">    alipay = get_ali_object()</span><br><span class="line">    <span class="comment">#调用退款方法</span></span><br><span class="line">    order_string = alipay.api_alipay_trade_refund(</span><br><span class="line">    <span class="comment">#订单号，一定要注意，这是支付成功后返回的唯一订单号</span></span><br><span class="line">    out_trade_no=<span class="string">"20190503214355"</span>,</span><br><span class="line">    <span class="comment">#退款金额，注意精确到分，不要超过订单支付总金额</span></span><br><span class="line">    refund_amount=<span class="string">"20.00"</span>,</span><br><span class="line">    <span class="comment">#回调网址</span></span><br><span class="line">    notify_url=<span class="string">'http://localhost:8000/md_admin/alipayreturn'</span></span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> HttpResponse(order_string)</span><br></pre></td></tr></table></figure><p>​    如果订单号和退款金额正确的话，请求该接口就会返回退款成功的返回值，查看支付宝钱包，相应的退款应该会及时到账</p><p>​    <img src="https://v3u.cn/v3u/Public/js/editor/attached/image/20190503/20190503160311_55332.png" alt="img"></p><p>​      值得一提的是，之前写得支付demo中，订单号的生成并不严谨，直接将time.time()拿来用了，其实应该将日期格式化这样订单号的可读性会增加，这里补上这个函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#根据日期生成唯一订单号</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_order_code</span><span class="params">()</span>:</span></span><br><span class="line">    order_no = str(time.strftime(<span class="string">'%Y%m%d%H%M%S'</span>, time.localtime(time.time())))</span><br><span class="line">    <span class="keyword">return</span> order_no</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      numpy的一些常见方法
    
    </summary>
    
      <category term="第三方支付" scheme="https://zxyyee.cn/categories/%E7%AC%AC%E4%B8%89%E6%96%B9%E6%94%AF%E4%BB%98/"/>
    
    
      <category term="第三方支付" scheme="https://zxyyee.cn/tags/%E7%AC%AC%E4%B8%89%E6%96%B9%E6%94%AF%E4%BB%98/"/>
    
  </entry>
  
  <entry>
    <title>docker与windows挂载失败</title>
    <link href="https://zxyyee.cn/post/docker%E4%B8%8Ewindows%E6%8C%82%E8%BD%BD%E5%A4%B1%E6%95%88.html"/>
    <id>https://zxyyee.cn/post/docker与windows挂载失效.html</id>
    <published>2018-01-28T14:43:24.000Z</published>
    <updated>2019-09-04T11:28:38.474Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Dcoker与windows挂载"><a href="#Dcoker与windows挂载" class="headerlink" title="Dcoker与windows挂载"></a>Dcoker与windows挂载</h3><p>1、打开VirtualBox软件  <img src="https://img-blog.csdn.net/20180125145339633?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxNDE0OTM5NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述">  2、找到运行的虚拟机，打开设置-&gt;共享文件夹  <img src="https://img-blog.csdn.net/20180125145349046?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxNDE0OTM5NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述">  3、设置共享文件夹路径，我这里设置的D盘docker文件夹,共享文件夹名称会自动设置，也可以自己手动设置，后边需要用到，自动挂载取消，一会自己手动挂载，设置完成后重启虚拟机。  <img src="https://img-blog.csdn.net/20180125145457690?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxNDE0OTM5NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"> </p><p>3.进入docker进行挂载,这里用配置fastdfs时的代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --network=host --name tracker -v /c/users:/var/root delron/fastdfs tracker</span><br></pre></td></tr></table></figure><p>​    到这里一切正常，但是问题出现了，怎么挂载都挂载不上。以为是代码的问题，尝试了各种路径已经各种文件。后来发现是VM VirtualBox的版本过低导致的，升级之后一切正常。</p><p>​    现在的开发环境都是在Mac中，但是在windows环境中遇到了也要及时解决。</p>]]></content>
    
    <summary type="html">
    
      docker与windows挂载失败
    
    </summary>
    
      <category term="Docker" scheme="https://zxyyee.cn/categories/Docker/"/>
    
    
      <category term="Docker" scheme="https://zxyyee.cn/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>部署爬虫与Django</title>
    <link href="https://zxyyee.cn/post/%E9%83%A8%E7%BD%B2%E7%88%AC%E8%99%AB%E4%B8%8EDjango.html"/>
    <id>https://zxyyee.cn/post/部署爬虫与Django.html</id>
    <published>2017-05-11T11:14:42.000Z</published>
    <updated>2019-09-04T11:29:26.450Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-编写爬虫"><a href="#1-编写爬虫" class="headerlink" title="1.编写爬虫"></a>1.编写爬虫</h4><h4 id="2-部署环境"><a href="#2-部署环境" class="headerlink" title="2.部署环境"></a>2.部署环境</h4><p>pip install scrapyd<br>pip install scrapyd-client<br>启动scrapyd的服务：cmd:&gt;scrapyd（必须处于开启状态）<br>在爬虫根目录执行：scrapyd-deploy,如果提示不是内部命令，需要修改配置文件。</p><h4 id="3-发布工程到scrapyd"><a href="#3-发布工程到scrapyd" class="headerlink" title="3.发布工程到scrapyd"></a>3.发布工程到scrapyd</h4><p>修改scrapy.cfg，去掉url前的#<br>进入到scrapy项目根目录，执行：scrapyd-deploy <target> -p <projectname>提示：（target:scrapy.cfg中[deploy:***]）（projectname：scrapy.cfg中project = XXX）<br>（#url中的#去掉）</projectname></target></p><h4 id="4-启动爬虫"><a href="#4-启动爬虫" class="headerlink" title="4.启动爬虫"></a>4.启动爬虫</h4><p>（命令式启动爬虫：<code>curl http://localhost:6800/schedule.json -d project=default -d spider=somespider</code>）</p><h4 id="5-启动django"><a href="#5-启动django" class="headerlink" title="5.启动django"></a>5.启动django</h4><p><code>cmd：python manage.py runserver</code></p><p>1.创建django项目，并编写models.py,启动django项目</p><p>2.Django项目根目录下创建Scrapy项目<br>（这是scrapy-djangoitem所需要的配置）<br>配置Django嵌入，在Scrapy的settings.py中加入以下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">sys.path.append(os.path.dirname(os.path.abspath(<span class="string">'.'</span>)))</span><br><span class="line"></span><br><span class="line">os.environ[<span class="string">'DJANGO_SETTINGS_MODULE'</span>] = <span class="string">'django项目名.settings'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> django</span><br><span class="line"></span><br><span class="line">django.setup()</span><br></pre></td></tr></table></figure><p>3.编写爬虫<br>4.item.py中引入Django模型类（pip install scrapy-djangoitem）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> 子应用 <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ScrapyabckgItem</span><span class="params">(DjangoItem)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 此处必须起名为django_model,主爬虫中使用item['title']=xxx</span></span><br><span class="line"></span><br><span class="line">    django_model = models.AbckgModel</span><br><span class="line"></span><br><span class="line"><span class="number">5.</span>pipelines.py中调用save()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ScrapyabckgPipeline</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_item</span><span class="params">(self, item, spider)</span>:</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 插入到数据库</span></span><br><span class="line"></span><br><span class="line">        item.save()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>  item <span class="comment">#将item传给下一个管道继续处理</span></span><br></pre></td></tr></table></figure><h4 id="6-启动爬虫-用命令，并非scrapyd启动-：scrapy-crawl-abckg"><a href="#6-启动爬虫-用命令，并非scrapyd启动-：scrapy-crawl-abckg" class="headerlink" title="6.启动爬虫(用命令，并非scrapyd启动)：scrapy  crawl  abckg"></a>6.启动爬虫(用命令，并非<code>scrapyd</code>启动)：<code>scrapy  crawl  abckg</code></h4><h4 id="7-刷新django-admin后台"><a href="#7-刷新django-admin后台" class="headerlink" title="7.刷新django-admin后台"></a>7.刷新django-admin后台</h4>]]></content>
    
    <summary type="html">
    
      分布式
    
    </summary>
    
      <category term="爬虫" scheme="https://zxyyee.cn/categories/%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="爬虫" scheme="https://zxyyee.cn/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>pandas方法</title>
    <link href="https://zxyyee.cn/post/pandas%E6%96%B9%E6%B3%95.html"/>
    <id>https://zxyyee.cn/post/pandas方法.html</id>
    <published>2017-03-28T11:13:34.000Z</published>
    <updated>2019-09-04T11:28:05.797Z</updated>
    
    <content type="html"><![CDATA[<h4 id="导入pandas库，一般都会用到numpy库"><a href="#导入pandas库，一般都会用到numpy库" class="headerlink" title="导入pandas库，一般都会用到numpy库"></a>导入pandas库，一般都会用到<code>numpy</code>库</h4><h2 id="使用iloc按位置区域提取数据"><a href="#使用iloc按位置区域提取数据" class="headerlink" title="使用iloc按位置区域提取数据"></a>使用iloc按位置区域提取数据</h2><p><code>df_inner.iloc[:3,:2</code>] #冒号前后的数字不再是索引的标签名称，而是数据所在的位置，从0开始，前三行，前两列。</p><h2 id="适应iloc按位置单独提起数据"><a href="#适应iloc按位置单独提起数据" class="headerlink" title="适应iloc按位置单独提起数据"></a>适应iloc按位置单独提起数据</h2><p><code>df_inner.iloc[[0,2,5],[4,5]]</code> #提取第0、2、5行，4、5列</p><h2 id="导入CSV等文件："><a href="#导入CSV等文件：" class="headerlink" title="导入CSV等文件："></a>导入CSV等文件：</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f = pd.DataFrame(pd.read_csv(‘name.csv’,header=<span class="number">1</span>)) </span><br><span class="line"></span><br><span class="line">df = pd.DataFrame(pd.read_excel(‘name.xlsx’))</span><br></pre></td></tr></table></figure><h2 id="维度查看："><a href="#维度查看：" class="headerlink" title="维度查看："></a>维度查看：</h2><h5 id="df-shape"><a href="#df-shape" class="headerlink" title="df.shape"></a><code>df.shape</code></h5><h2 id="数据表基本信息（维度、列名称、数据格式、所占空间等）："><a href="#数据表基本信息（维度、列名称、数据格式、所占空间等）：" class="headerlink" title="数据表基本信息（维度、列名称、数据格式、所占空间等）："></a>数据表基本信息（维度、列名称、数据格式、所占空间等）：</h2><h5 id="df-info"><a href="#df-info" class="headerlink" title="df.info()"></a><code>df.info()</code></h5><h2 id="每一列数据的格式："><a href="#每一列数据的格式：" class="headerlink" title="每一列数据的格式："></a>每一列数据的格式：</h2><h5 id="df-dtypes"><a href="#df-dtypes" class="headerlink" title="df.dtypes"></a><code>df.dtypes</code></h5><h2 id="某一列格式："><a href="#某一列格式：" class="headerlink" title="某一列格式："></a>某一列格式：</h2><h5 id="df-‘B’-dtype"><a href="#df-‘B’-dtype" class="headerlink" title="df[‘B’].dtype"></a><code>df[‘B’].dtype</code></h5><h2 id="空值："><a href="#空值：" class="headerlink" title="空值："></a>空值：</h2><h5 id="df-isnull"><a href="#df-isnull" class="headerlink" title="df.isnull()"></a><code>df.isnull()</code></h5><h2 id="查看某一列空值："><a href="#查看某一列空值：" class="headerlink" title="查看某一列空值："></a>查看某一列空值：</h2><h5 id="df-isnull-1"><a href="#df-isnull-1" class="headerlink" title="df.isnull()"></a><code>df.isnull()</code></h5><h2 id="查看某一列的唯一值："><a href="#查看某一列的唯一值：" class="headerlink" title="查看某一列的唯一值："></a>查看某一列的唯一值：</h2><h5 id="df-‘B’-unique"><a href="#df-‘B’-unique" class="headerlink" title="df[‘B’].unique()"></a><code>df[‘B’].unique()</code></h5><h2 id="查看数据表的值："><a href="#查看数据表的值：" class="headerlink" title="查看数据表的值："></a>查看数据表的值：</h2><h5 id="df-values"><a href="#df-values" class="headerlink" title="df.values"></a><code>df.values</code></h5><h2 id="查看列名称："><a href="#查看列名称：" class="headerlink" title="查看列名称："></a>查看列名称：</h2><h5 id="df-columns"><a href="#df-columns" class="headerlink" title="df.columns"></a><code>df.columns</code></h5><h2 id="1查看前10行数据、后10行数据："><a href="#1查看前10行数据、后10行数据：" class="headerlink" title="1查看前10行数据、后10行数据："></a>1查看前10行数据、后10行数据：</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">df.head() <span class="comment">#默认前10行数据 </span></span><br><span class="line"></span><br><span class="line">df.tail() <span class="comment">#默认后10 行数据</span></span><br></pre></td></tr></table></figure><h2 id="用数字0填充空值："><a href="#用数字0填充空值：" class="headerlink" title="用数字0填充空值："></a>用数字0填充空值：</h2><h5 id="df-fillna-value-0"><a href="#df-fillna-value-0" class="headerlink" title="df.fillna(value=0)"></a><code>df.fillna(value=0)</code></h5><h2 id="使用列prince的均值对NA进行填充："><a href="#使用列prince的均值对NA进行填充：" class="headerlink" title="使用列prince的均值对NA进行填充："></a>使用列prince的均值对NA进行填充：</h2><h5 id="df-‘prince’-fillna-df-‘prince’-mean"><a href="#df-‘prince’-fillna-df-‘prince’-mean" class="headerlink" title="df[‘prince’].fillna(df[‘prince’].mean())"></a><code>df[‘prince’].fillna(df[‘prince’].mean())</code></h5><h2 id="清楚city字段的字符空格："><a href="#清楚city字段的字符空格：" class="headerlink" title="清楚city字段的字符空格："></a>清楚city字段的字符空格：</h2><h5 id="df-‘city’-df-‘city’-map-str-strip"><a href="#df-‘city’-df-‘city’-map-str-strip" class="headerlink" title="df[‘city’]=df[‘city’].map(str.strip)"></a><code>df[‘city’]=df[‘city’].map(str.strip)</code></h5><h2 id="大小写转换："><a href="#大小写转换：" class="headerlink" title="大小写转换："></a>大小写转换：</h2><h5 id="df-‘city’-df-‘city’-str-lower"><a href="#df-‘city’-df-‘city’-str-lower" class="headerlink" title="df[‘city’]=df[‘city’].str.lower()"></a><code>df[‘city’]=df[‘city’].str.lower()</code></h5><h2 id="更改数据格式："><a href="#更改数据格式：" class="headerlink" title="更改数据格式："></a>更改数据格式：</h2><h5 id="df-‘price’-astype-‘int’"><a href="#df-‘price’-astype-‘int’" class="headerlink" title="df[‘price’].astype(‘int’)"></a><code>df[‘price’].astype(‘int’)</code></h5><h2 id="更改列名称："><a href="#更改列名称：" class="headerlink" title="更改列名称："></a>更改列名称：</h2><h5 id="df-rename-columns-‘category’-‘category-size’"><a href="#df-rename-columns-‘category’-‘category-size’" class="headerlink" title="df.rename(columns={‘category’: ‘category-size’})"></a><code>df.rename(columns={‘category’: ‘category-size’})</code></h5><h2 id="删除后出现的重复值："><a href="#删除后出现的重复值：" class="headerlink" title="删除后出现的重复值："></a>删除后出现的重复值：</h2><h5 id="df-‘city’-drop-duplicates"><a href="#df-‘city’-drop-duplicates" class="headerlink" title="df[‘city’].drop_duplicates()"></a><code>df[‘city’].drop_duplicates()</code></h5><h2 id="删除先出现的重复值："><a href="#删除先出现的重复值：" class="headerlink" title="删除先出现的重复值："></a>删除先出现的重复值：</h2><h5 id="df-‘city’-drop-duplicates-keep-’last’"><a href="#df-‘city’-drop-duplicates-keep-’last’" class="headerlink" title="df[‘city’].drop_duplicates(keep=’last’)"></a><code>df[‘city’].drop_duplicates(keep=’last’)</code></h5><h2 id="数据替换："><a href="#数据替换：" class="headerlink" title="数据替换："></a>数据替换：</h2><h5 id="df-‘city’-replace-‘sh’-‘shanghai’"><a href="#df-‘city’-replace-‘sh’-‘shanghai’" class="headerlink" title="df[‘city’].replace(‘sh’, ‘shanghai’)"></a><code>df[‘city’].replace(‘sh’, ‘shanghai’)</code></h5><h2 id="使用“与”进行筛选"><a href="#使用“与”进行筛选" class="headerlink" title="使用“与”进行筛选"></a>使用“与”进行筛选</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df_inner.loc[(df_inner[‘age’] &gt; <span class="number">25</span>) &amp; (df_inner[‘city’] == ‘beijing’), [‘id’,’city’,’age’,’category’,’gender’]]</span><br></pre></td></tr></table></figure><h2 id="使用“或”进行筛选"><a href="#使用“或”进行筛选" class="headerlink" title="使用“或”进行筛选"></a>使用“或”进行筛选</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df_inner.loc[(df_inner[‘age’] &gt; 25) | (df_inner[‘city’] == ‘beijing’), [‘id’,’city’,’age’,’category’,’gender’]].sort([‘age’])</span><br></pre></td></tr></table></figure><h2 id="使用“非”条件进行筛选"><a href="#使用“非”条件进行筛选" class="headerlink" title="使用“非”条件进行筛选"></a>使用“非”条件进行筛选</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df_inner.loc[(df_inner[‘city’] != ‘beijing’), [‘id’,’city’,’age’,’category’,’gender’]].sort([‘id’])</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      pandas的一些常见方法
    
    </summary>
    
      <category term="机器学习" scheme="https://zxyyee.cn/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="机器学习" scheme="https://zxyyee.cn/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="Python" scheme="https://zxyyee.cn/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>numpy方法</title>
    <link href="https://zxyyee.cn/post/numpy%E6%96%B9%E6%B3%95.html"/>
    <id>https://zxyyee.cn/post/numpy方法.html</id>
    <published>2017-02-28T11:13:24.000Z</published>
    <updated>2019-09-04T11:28:10.783Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-NumPy"><a href="#1-NumPy" class="headerlink" title="1.NumPy"></a>1.NumPy</h3><p>　　NumPy是高性能科学计算和数据分析的基础包。部分功能如下：</p><p>ndarray, 具有矢量算术运算和复杂广播能力的快速且节省空间的多维数组。<br>用于对整组数据进行快速运算的标准数学函数（无需编写循环）。<br>用于读写磁盘数据的工具以及用于操作内存映射文件的工具。<br>线性代数、随机数生成以及傅里叶变换功能。<br>用于集成C、C++、Fortran等语言编写的代码的工具。<br>　　首先要导入numpy库：import numpy as np</p><table><thead><tr><th>生成函数</th><th align="center">作用</th></tr></thead><tbody><tr><td></td><td align="center">np.array( x)</td></tr><tr><td>np.array( x, dtype)</td><td align="center">将输入数据转化为一个类型为type的ndarray</td></tr><tr><td></td><td align="center">np.asarray( array )</td></tr><tr><td>np.ones( N )</td><td align="center">生成一个N长度的一维全一ndarray</td></tr><tr><td>np.ones( N, dtype)</td><td align="center">生成一个N长度类型是dtype的一维全一ndarray</td></tr><tr><td>np.ones_like( ndarray )</td><td align="center">生成一个形状与参数相同的全一ndarray</td></tr><tr><td>np.zeros( N)</td><td align="center">生成一个N长度的一维全零ndarray</td></tr><tr><td>np.zeros( N, dtype)</td><td align="center">生成一个N长度类型位dtype的一维全零ndarray</td></tr><tr><td>np.zeros_like(ndarray)</td><td align="center">类似np.ones_like( ndarray )</td></tr><tr><td>np.empty( N )</td><td align="center">生成一个N长度的未初始化一维ndarray</td></tr><tr><td>np.empty( N, dtype)</td><td align="center">生成一个N长度类型是dtype的未初始化一维ndarray</td></tr><tr><td>np.empty(ndarray)</td><td align="center">类似np.ones_like( ndarray )</td></tr><tr><td>np.eye( N )</td><td align="center">创建一个N * N的单位矩阵（对角线为1，其余为0）</td></tr><tr><td>np.identity( N )</td><td align="center">创建一个N * N的单位矩阵（对角线为1，其余为0）</td></tr><tr><td>np.arange( num)</td><td align="center">生成一个从0到num-1步数为1的一维ndarray</td></tr><tr><td>np.arange( begin, end)</td><td align="center">生成一个从begin到end-1步数为1的一维ndarray</td></tr><tr><td>np.arange( begin, end, step)</td><td align="center">生成一个从begin到end-step的步数为step的一维ndarray</td></tr><tr><td>np.mershgrid(ndarray, ndarray,…)</td><td align="center">生成一个ndarray * ndarray * …的多维ndarray</td></tr><tr><td>np.where(cond, ndarray1, ndarray2)</td><td align="center">根据条件cond，选取ndarray1或者ndarray2，返回一个新的ndarray</td></tr><tr><td>np.in1d(ndarray, [x,y,…])</td><td align="center">检查ndarray中的元素是否等于[x,y,…]中的一个，返回bool数组</td></tr></tbody></table><table><thead><tr><th align="left">矩阵函数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">np.diag( ndarray)</td><td align="left">以一维数组的形式返回方阵的对角线（或非对角线）元素</td></tr><tr><td align="left">np.diag( [x,y,…])</td><td align="left">将一维数组转化为方阵（非对角线元素为0）</td></tr><tr><td align="left">np.dot(ndarray, ndarray)</td><td align="left">矩阵乘法</td></tr><tr><td align="left">np.trace( ndarray)</td><td align="left">计算对角线元素的和</td></tr></tbody></table><table><thead><tr><th align="left">排序函数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">np.sort( ndarray)</td><td align="left">排序，返回副本</td></tr><tr><td align="left">np.unique(ndarray)</td><td align="left">返回ndarray中的元素，排除重复元素之后，并进行排序</td></tr><tr><td align="left">np.intersect1d( ndarray1, ndarray2)</td><td align="left">返回二者的交集并排序。</td></tr><tr><td align="left">np.union1d( ndarray1, ndarray2)</td><td align="left">返回二者的并集并排序。</td></tr><tr><td align="left">np.setdiff1d( ndarray1, ndarray2)</td><td align="left">返回二者的差。</td></tr><tr><td align="left">np.setxor1d( ndarray1, ndarray2)</td><td align="left">返回二者的对称差</td></tr></tbody></table><table><thead><tr><th align="left">一元计算函数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">np.abs(ndarray)</td><td align="left">计算绝对值</td></tr><tr><td align="left">np.fabs(ndarray)</td><td align="left">计算绝对值（非复数）</td></tr><tr><td align="left">np.mean(ndarray)</td><td align="left">求平均值</td></tr><tr><td align="left">np.sqrt(ndarray)</td><td align="left">计算x^0.5</td></tr><tr><td align="left">np.square(ndarray)</td><td align="left">计算x^2</td></tr><tr><td align="left">np.exp(ndarray)</td><td align="left">计算e^x</td></tr><tr><td align="left">log、log10、log2、log1p</td><td align="left">计算自然对数、底为10的log、底为2的log、底为(1+x)的log</td></tr><tr><td align="left">np.sign(ndarray)</td><td align="left">计算正负号：1（正）、0（0）、-1（负）</td></tr><tr><td align="left">np.ceil(ndarray)</td><td align="left">计算大于等于改值的最小整数</td></tr><tr><td align="left">np.floor(ndarray)</td><td align="left">计算小于等于该值的最大整数</td></tr><tr><td align="left">np.rint(ndarray)</td><td align="left">四舍五入到最近的整数，保留dtype</td></tr><tr><td align="left">np.modf(ndarray)</td><td align="left">将数组的小数和整数部分以两个独立的数组方式返回</td></tr><tr><td align="left">np.isnan(ndarray)</td><td align="left">返回一个判断是否是NaN的bool型数组</td></tr><tr><td align="left">np.isfinite(ndarray)</td><td align="left">返回一个判断是否是有穷（非inf，非NaN）的bool型数组</td></tr><tr><td align="left">np.isinf(ndarray)</td><td align="left">返回一个判断是否是无穷的bool型数组</td></tr><tr><td align="left">cos、cosh、sin、sinh、tan、tanh</td><td align="left">普通型和双曲型三角函数</td></tr><tr><td align="left">arccos、arccosh、arcsin、arcsinh、arctan、arctanh</td><td align="left">反三角函数和双曲型反三角函数</td></tr><tr><td align="left">np.logical_not(ndarray)</td><td align="left">计算各元素not x的真值，相当于-ndarray</td></tr></tbody></table><table><thead><tr><th align="left">多元计算函数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">np.add(ndarray, ndarray)</td><td align="left">相加</td></tr><tr><td align="left">np.subtract(ndarray, ndarray)</td><td align="left">相减</td></tr><tr><td align="left">np.multiply(ndarray, ndarray)</td><td align="left">乘法</td></tr><tr><td align="left">np.divide(ndarray, ndarray)</td><td align="left">除法</td></tr><tr><td align="left">np.floor_divide(ndarray, ndarray)</td><td align="left">圆整除法（丢弃余数）</td></tr><tr><td align="left">np.power(ndarray, ndarray)</td><td align="left">次方</td></tr><tr><td align="left">np.mod(ndarray, ndarray)</td><td align="left">求模</td></tr><tr><td align="left">np.maximum(ndarray, ndarray)</td><td align="left">求最大值</td></tr><tr><td align="left">np.fmax(ndarray, ndarray)</td><td align="left">求最大值（忽略NaN）</td></tr><tr><td align="left">np.minimun(ndarray, ndarray)</td><td align="left">求最小值</td></tr><tr><td align="left">np.fmin(ndarray, ndarray)</td><td align="left">求最小值（忽略NaN）</td></tr><tr><td align="left">np.copysign(ndarray, ndarray)</td><td align="left">将参数2中的符号赋予参数1</td></tr><tr><td align="left">np.greater(ndarray, ndarray)</td><td align="left">&gt;</td></tr><tr><td align="left">np.greater_equal(ndarray, ndarray)</td><td align="left">&gt;=</td></tr><tr><td align="left">np.less(ndarray, ndarray)</td><td align="left">&lt;</td></tr><tr><td align="left">np.less_equal(ndarray, ndarray)</td><td align="left">&lt;=</td></tr><tr><td align="left">np.equal(ndarray, ndarray)</td><td align="left">==</td></tr><tr><td align="left">np.not_equal(ndarray, ndarray)</td><td align="left">!=</td></tr><tr><td align="left">logical_and(ndarray, ndarray)</td><td align="left">&amp;</td></tr><tr><td align="left">logical_or(ndarray, ndarray)</td><td align="left"><strong>|</strong></td></tr><tr><td align="left"></td><td align="left">logical_xor(ndarray, ndarray)</td></tr><tr><td align="left">np.dot( ndarray, ndarray)</td><td align="left">计算两个ndarray的矩阵内积</td></tr><tr><td align="left">np.ix_([x,y,m,n],…)</td><td align="left">生成一个索引器，用于Fancy indexing(花式索引)</td></tr></tbody></table><table><thead><tr><th align="left">文件读写</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">np.save(string, ndarray)</td><td align="left">将ndarray保存到文件名为 [string].npy 的文件中（无压缩）</td></tr><tr><td align="left">np.savez(string, ndarray1, ndarray2, …)</td><td align="left">将所有的ndarray压缩保存到文件名为[string].npy的文件中</td></tr><tr><td align="left">np.savetxt(sring, ndarray, fmt, newline=’\n’)</td><td align="left">将ndarray写入文件，格式为fmt</td></tr><tr><td align="left">np.load(string)</td><td align="left">读取文件名string的文件内容并转化为ndarray对象（或字典对象）</td></tr><tr><td align="left">np.loadtxt(string, delimiter)</td><td align="left">读取文件名string的文件内容，以delimiter为分隔符转化为ndarray</td></tr></tbody></table><p><strong>表2.1.A.2 np常用函数</strong></p><table><thead><tr><th align="left">B NumPy.ndarray函数</th><th align="left">属性：</th></tr></thead><tbody><tr><td align="left">ndarray.ndim</td><td align="left">获取ndarray的维数</td></tr><tr><td align="left">ndarray.shape</td><td align="left">获取ndarray各个维度的长度</td></tr><tr><td align="left">ndarray.dtype</td><td align="left">获取ndarray中元素的数据类型</td></tr><tr><td align="left">ndarray.T</td><td align="left">简单转置矩阵ndarray</td></tr></tbody></table><p><strong>表2.1.B.1 ndarray属性</strong></p><table><thead><tr><th align="left">函数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">ndarray.astype(dtype)</td><td align="left">转换类型，若转换失败则会出现TypeError</td></tr><tr><td align="left">ndarray.copy()</td><td align="left">复制一份ndarray(新的内存空间)</td></tr><tr><td align="left">ndarray.reshape((N,M,…))</td><td align="left">将ndarray转化为N<em>M</em>…的多维ndarray（非copy）</td></tr><tr><td align="left">ndarray.transpose((xIndex,yIndex,…))</td><td align="left">根据维索引xIndex,yIndex…进行矩阵转置，依赖于shape，不能用于一维矩阵（非copy）</td></tr><tr><td align="left">ndarray.swapaxes(xIndex,yIndex)</td><td align="left">交换维度（非copy）</td></tr></tbody></table><table><thead><tr><th align="left">计算函数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">ndarray.mean( axis=0 )</td><td align="left">求平均值</td></tr><tr><td align="left">ndarray.sum( axis= 0)</td><td align="left">求和</td></tr><tr><td align="left">ndarray.cumsum( axis=0)</td><td align="left">累加</td></tr><tr><td align="left">ndarray.cumprod( axis=0)</td><td align="left">累乘</td></tr><tr><td align="left">ndarray.std()</td><td align="left">方差</td></tr><tr><td align="left">ndarray.var()</td><td align="left">标准差</td></tr><tr><td align="left">ndarray.max()</td><td align="left">最大值</td></tr><tr><td align="left">ndarray.min()</td><td align="left">最小值</td></tr><tr><td align="left">ndarray.argmax()</td><td align="left">最大值索引</td></tr><tr><td align="left">ndarray.argmin()</td><td align="left">最小值索引</td></tr><tr><td align="left">ndarray.any()</td><td align="left">是否至少有一个True</td></tr><tr><td align="left">ndarray.all()</td><td align="left">是否全部为True</td></tr><tr><td align="left">ndarray.dot( ndarray)</td><td align="left">计算矩阵内积</td></tr></tbody></table><table><thead><tr><th align="left">排序函数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">ndarray.sort(axis=0)</td><td align="left">排序，返回源数据</td></tr></tbody></table><p><strong>表2.1.B.2 ndarray函数</strong></p><table><thead><tr><th align="left">ndarray函数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">ndarray[n]</td><td align="left">选取第n+1个元素</td></tr><tr><td align="left">ndarray[n:m]</td><td align="left">选取第n+1到第m个元素</td></tr><tr><td align="left">ndarray[:]</td><td align="left">选取全部元素</td></tr><tr><td align="left">ndarray[n:]</td><td align="left">选取第n+1到最后一个元素</td></tr><tr><td align="left">ndarray[:n]</td><td align="left">选取第0到第n个元素</td></tr><tr><td align="left">ndarray[ bool_ndarray ]</td><td align="left">注：bool_ndarray表示bool类型的ndarray选取为true的元素</td></tr><tr><td align="left">ndarray[[x,y,m,n]]…</td><td align="left">选取顺序和序列为x、y、m、n的ndarray</td></tr><tr><td align="left">ndarray[n,m]</td><td align="left">选取第n+1行第m+1个元素</td></tr><tr><td align="left">ndarray[n][m]</td><td align="left">选取第n+1行第m+1个元素</td></tr><tr><td align="left">ndarray[n,m,…]</td><td align="left">选取n行n列….的元素</td></tr><tr><td align="left">ndarray[n][m]….</td><td align="left">选取n行n列….的元素</td></tr></tbody></table><p><strong>表2.1.B.3 ndarray索引/切片方式</strong></p><p>　　C NumPy.random函数和属性：</p><table><thead><tr><th align="left">函数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">seed()</td><td align="left">确定随机数生成种子</td></tr><tr><td align="left">seed(int)</td><td align="left">确定随机数生成种子</td></tr><tr><td align="left">seed(ndarray)</td><td align="left">确定随机数生成种子</td></tr><tr><td align="left">permutation(int)</td><td align="left">返回一个一维从0~9的序列的随机排列</td></tr><tr><td align="left">permutation(ndarray)</td><td align="left">返回一个序列的随机排列</td></tr><tr><td align="left">shuffle(ndarray)</td><td align="left">对一个序列就地随机排列</td></tr><tr><td align="left">rand(int)</td><td align="left">产生int个均匀分布的样本值</td></tr><tr><td align="left">randint(begin,end,num=1)</td><td align="left">从给定的begin和end随机选取num个整数</td></tr><tr><td align="left">randn(N, M, …)</td><td align="left">生成一个N<em>M</em>…的正态分布（平均值为0，标准差为1）的ndarray</td></tr><tr><td align="left">normal(size=(N,M,…))</td><td align="left">生成一个N<em>M</em>…的正态（高斯）分布的ndarray</td></tr><tr><td align="left">beta(ndarray1,ndarray2)</td><td align="left">产生beta分布的样本值，参数必须大于0</td></tr><tr><td align="left">chisquare()</td><td align="left">产生卡方分布的样本值</td></tr><tr><td align="left">gamma()</td><td align="left">产生gamma分布的样本值</td></tr><tr><td align="left">uniform()</td><td align="left">产生在[0,1)中均匀分布的样本值</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      numpy的一些常见方法
    
    </summary>
    
      <category term="机器学习" scheme="https://zxyyee.cn/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="机器学习" scheme="https://zxyyee.cn/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="Python" scheme="https://zxyyee.cn/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>跨域问题</title>
    <link href="https://zxyyee.cn/post/%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98.html"/>
    <id>https://zxyyee.cn/post/跨域问题.html</id>
    <published>2017-02-28T11:13:24.000Z</published>
    <updated>2019-09-04T11:29:41.543Z</updated>
    
    <content type="html"><![CDATA[<h1 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h1><p>出于浏览器的同源策略限制。同源策略（Sameoriginpolicy）是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，则浏览器的正常功能可能都会受到影响。可以说Web是构建在同源策略基础之上的，浏览器只是针对同源策略的一种实现。同源策略会阻止一个域的javascript脚本和另外一个域的内容进行交互。所谓同源（即指在同一个域）就是两个页面具有相同的协议（protocol），主机（host）和端口号（port）</p><h1 id="非同源限制"><a href="#非同源限制" class="headerlink" title="非同源限制"></a>非同源限制</h1><p>【1】无法读取非同源网页的 Cookie、LocalStorage 和 IndexedDB</p><p>【2】无法接触非同源网页的 DOM</p><p>【3】无法向非同源地址发送 AJAX 请求</p><h1 id="解决跨域问题"><a href="#解决跨域问题" class="headerlink" title="解决跨域问题"></a>解决跨域问题</h1><p>tornado可以在基础视图(baseHander)内添加请求头</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">from tornado.web import RequestHandler</span><br><span class="line"></span><br><span class="line">class BaseHandler(RequestHandler):</span><br><span class="line">    def set_default_headers(self):</span><br><span class="line">        print(&quot;setting headers!!!&quot;)</span><br><span class="line">        self.set_header(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;) # 这个地方可以写域名</span><br><span class="line">        self.set_header(&quot;Access-Control-Allow-Headers&quot;, &quot;x-requested-with&quot;)</span><br><span class="line">        self.set_header(&apos;Access-Control-Allow-Methods&apos;, &apos;POST, GET, OPTIONS,PUT,DELETE&apos;)</span><br></pre></td></tr></table></figure><p>而django这种走大而全路线的框架，直接使用三方组件就可以解决这个问题,但是需要修改一些配置文件，没有tornado灵活</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">pip3 install django-cors-headers</span><br><span class="line">INSTALLED_APPS = [</span><br><span class="line">    <span class="string">'django.contrib.admin'</span>,</span><br><span class="line">    <span class="string">'django.contrib.auth'</span>,</span><br><span class="line">    <span class="string">'django.contrib.contenttypes'</span>,</span><br><span class="line">    <span class="string">'django.contrib.sessions'</span>,</span><br><span class="line">    <span class="string">'django.contrib.messages'</span>,</span><br><span class="line">    <span class="string">'django.contrib.staticfiles'</span>,</span><br><span class="line">    <span class="string">'mymac'</span>,</span><br><span class="line">    <span class="string">'myapp'</span>,</span><br><span class="line">    <span class="string">'corsheaders'</span>,</span><br><span class="line">    <span class="string">'djcelery'</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">MIDDLEWARE = [</span><br><span class="line">    <span class="string">'django.middleware.security.SecurityMiddleware'</span>,</span><br><span class="line">    <span class="string">'django.contrib.sessions.middleware.SessionMiddleware'</span>,</span><br><span class="line">    <span class="comment">#定义跨域中间件</span></span><br><span class="line">    <span class="string">'corsheaders.middleware.CorsMiddleware'</span>,</span><br><span class="line">    <span class="string">'django.middleware.common.CommonMiddleware'</span>,</span><br><span class="line">    <span class="comment">#'django.middleware.csrf.CsrfViewMiddleware',</span></span><br><span class="line">    <span class="string">'django.contrib.auth.middleware.AuthenticationMiddleware'</span>,</span><br><span class="line">    <span class="string">'django.contrib.messages.middleware.MessageMiddleware'</span>,</span><br><span class="line">    <span class="string">'django.middleware.clickjacking.XFrameOptionsMiddleware'</span>,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      跨域问题
    
    </summary>
    
      <category term="Python" scheme="https://zxyyee.cn/categories/Python/"/>
    
    
      <category term="Python" scheme="https://zxyyee.cn/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>linux基础操作</title>
    <link href="https://zxyyee.cn/post/linux%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C.html"/>
    <id>https://zxyyee.cn/post/linux基础操作.html</id>
    <published>2016-07-28T11:12:31.000Z</published>
    <updated>2019-09-04T11:28:23.295Z</updated>
    
    <content type="html"><![CDATA[<h4 id="建立文件夹"><a href="#建立文件夹" class="headerlink" title="建立文件夹"></a>建立文件夹</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mkdir      <span class="comment">#建立单目录</span></span><br><span class="line"></span><br><span class="line">mkdir -p    <span class="comment">#建立多层目录</span></span><br><span class="line"></span><br><span class="line">eg：mkdir -p  <span class="number">123</span>/<span class="number">456</span>/<span class="number">789</span>     <span class="comment">#在Desktop中创建123文件夹，在123中创建456文件夹，在456中创建789文件夹</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#实现了文件夹的多级目录创建</span></span><br></pre></td></tr></table></figure><h4 id="文件夹的删除"><a href="#文件夹的删除" class="headerlink" title="文件夹的删除"></a>文件夹的删除</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rm  file          <span class="comment"># 删除file'文件夹，但是会提示是否删除，选择yes或者no</span></span><br><span class="line"></span><br><span class="line">rm -f file          <span class="comment">#强行删除文件不提示</span></span><br><span class="line"></span><br><span class="line">rm -fr dir      <span class="comment"># 强行删除目录本身和里面的内容补提时</span></span><br></pre></td></tr></table></figure><h4 id="文件的编辑"><a href="#文件的编辑" class="headerlink" title="文件的编辑"></a>文件的编辑</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">vim  file    <span class="comment">#进入file文件编译</span></span><br><span class="line"></span><br><span class="line">i：<span class="comment">#插入</span></span><br><span class="line"></span><br><span class="line">esc+:</span><br><span class="line"></span><br><span class="line">wq</span><br><span class="line"></span><br><span class="line">！<span class="comment">#强制执行</span></span><br></pre></td></tr></table></figure><h4 id="文件查看常用命令"><a href="#文件查看常用命令" class="headerlink" title="文件查看常用命令"></a>文件查看常用命令</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">cat file             <span class="comment">#输出文件的所有内容</span></span><br><span class="line"></span><br><span class="line">cat -b file         <span class="comment">#输出文件所有内容并加入行号</span></span><br><span class="line"></span><br><span class="line">less                 <span class="comment">#分页浏览        在分页浏览下：上|下        向上|向下移动一行              &lt;pgup&gt;|&lt;pgdn&gt;      向上|向下移动一页</span></span><br><span class="line"></span><br><span class="line">/关键字           <span class="comment">#高亮显示关键字，n向下匹配N向上匹配</span></span><br><span class="line"></span><br><span class="line">q                      <span class="comment">#退出</span></span><br><span class="line"></span><br><span class="line">tail -n               <span class="comment">#显示文件的后多少行</span></span><br></pre></td></tr></table></figure><h4 id="文件的复制和移动"><a href="#文件的复制和移动" class="headerlink" title="文件的复制和移动"></a>文件的复制和移动</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">cp file file222                                <span class="comment">#文件复制(将文件file复制到file222中）</span></span><br><span class="line"></span><br><span class="line">cp file file222 <span class="number">123</span>/                       <span class="comment">#复制多个文件（file file222）到目录（123）中</span></span><br><span class="line"></span><br><span class="line">cp -r  file    <span class="number">123</span>/                            <span class="comment">#复制目录（123）</span></span><br><span class="line"></span><br><span class="line">mv  file file222              <span class="comment">#重名命</span></span><br><span class="line"></span><br><span class="line">mv  file  <span class="number">123</span>                 <span class="comment">#移动</span></span><br><span class="line"></span><br><span class="line">mv file   <span class="number">123</span>                <span class="comment">#移动目录</span></span><br></pre></td></tr></table></figure><h4 id="文件路径"><a href="#文件路径" class="headerlink" title="文件路径"></a>文件路径</h4><p>相对路径：（则必须有前提条件，其实在系统底层依然是绝对路径执行，只是用户看到的简略移动）</p><p>文件相对当前系统位置的一个名称简写<br>文件名称省略了当前路径的值<br>只有当前在此目录中时可以使用<br>文件名称不以/开头<br>文件名称会自动在字符前加入’pwd’显示的路径</p><p>绝对路径：</p><p>是文件在系统中真实的位置<br>任何时间都可以精确表示一个文件的名称<br>文件名称以/开头</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pwd            <span class="comment">#显示当前工作目录</span></span><br><span class="line"></span><br><span class="line">cd               <span class="comment">#切换当前工作目录</span></span><br><span class="line"></span><br><span class="line">cd /mnt      <span class="comment">#切换到/mnt目录中</span></span><br><span class="line"></span><br><span class="line">cd -             <span class="comment">#进入当前目录之前所在目录中</span></span><br><span class="line"></span><br><span class="line">cd ~student        <span class="comment">#进入到student用户家目录</span></span><br></pre></td></tr></table></figure><h4 id="系统目录各个文件夹介绍："><a href="#系统目录各个文件夹介绍：" class="headerlink" title="系统目录各个文件夹介绍："></a>系统目录各个文件夹介绍：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">/bin        <span class="comment">##二进制文件，系统常规命令</span></span><br><span class="line"></span><br><span class="line">/boot        <span class="comment">##系统启动分区，系统启动时读取的文件</span></span><br><span class="line"></span><br><span class="line">/dev        <span class="comment">##设备文件</span></span><br><span class="line"></span><br><span class="line">/etc        <span class="comment">##大多数配置文件</span></span><br><span class="line"></span><br><span class="line">/home        <span class="comment">##普通用户的家目录</span></span><br><span class="line"></span><br><span class="line">/lib        <span class="comment">##32位函数库</span></span><br><span class="line"></span><br><span class="line">/lib64        <span class="comment">##64位库</span></span><br><span class="line"></span><br><span class="line">/media        <span class="comment">##手动临时挂载点</span></span><br><span class="line"></span><br><span class="line">/mnt        <span class="comment">##手动临时挂载点</span></span><br><span class="line"></span><br><span class="line">/opt        <span class="comment">##第三方软件安装位置</span></span><br><span class="line"></span><br><span class="line">/proc        <span class="comment">##进程信息及硬件信息</span></span><br><span class="line"></span><br><span class="line">/root        <span class="comment">##超级用户家目录</span></span><br><span class="line"></span><br><span class="line">/run        <span class="comment">##临时设备的默认挂载点</span></span><br><span class="line"></span><br><span class="line">/sbin        <span class="comment">##系统管理命令</span></span><br><span class="line"></span><br><span class="line">/srv        <span class="comment">##数据</span></span><br><span class="line"></span><br><span class="line">/var        <span class="comment">##数据</span></span><br><span class="line"></span><br><span class="line">/sys        <span class="comment">##内核相关信息</span></span><br><span class="line"></span><br><span class="line">/tmp        <span class="comment">##临时文件</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      Linux
    
    </summary>
    
      <category term="Linux" scheme="https://zxyyee.cn/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://zxyyee.cn/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>装饰器</title>
    <link href="https://zxyyee.cn/post/%E8%A3%85%E9%A5%B0%E5%99%A8.html"/>
    <id>https://zxyyee.cn/post/装饰器.html</id>
    <published>2016-06-23T03:13:24.000Z</published>
    <updated>2019-09-04T11:30:05.953Z</updated>
    
    <content type="html"><![CDATA[<h1 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h1><p>装饰器本质其实就是一个函数, 可以让其它函数不改动源代码的情况下增加其他新功能, 比如网站经常需要的权限校验等场景</p><p>我们有一个新需求, 计算代码执行时间</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    start_time = time.time</span><br><span class="line">    print(x+y)</span><br><span class="line">    stop_time = time.time</span><br><span class="line">    print(<span class="string">"&#123;func&#125; spend &#123;time&#125; "</span>.format(func = <span class="string">"add"</span>, time = stop_time-start_time))</span><br><span class="line"></span><br><span class="line">add(<span class="number">1</span>,<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>可以这么写，但是一来修改了源代码可能会造成一些未知的错误, 二来如果我们有一百个函数, 这样写也不现实, 这就是我们装饰器出场的时候了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">timmer</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    :param func: 被装饰的函数</span></span><br><span class="line"><span class="string">    :return: 一个计算函数运行时间的函数</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :param args:收集被装饰函数的参数</span></span><br><span class="line"><span class="string">        :param kwargs:收集被装饰函数的关键字参数</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        start_time = time.time()</span><br><span class="line">        <span class="comment"># 让进程睡一秒</span></span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">        <span class="comment"># 调用被装饰的函数</span></span><br><span class="line">        result = func(*args, **kwargs)</span><br><span class="line">        stop_time = time.time()</span><br><span class="line">        print(<span class="string">"&#123;func&#125; spend &#123;time&#125; "</span>.format(func = <span class="string">"add"</span>, time = stop_time-start_time))</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure><p>使用装饰器</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    print(x,y)</span><br><span class="line"><span class="comment"># 因为timmer返回的是wrapper函数对象,所以执行add()相当于执行wrapper()</span></span><br><span class="line">add = timmer(add)</span><br><span class="line">add(<span class="number">1</span>,<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>语法糖</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@timmer</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    print(x,y)</span><br><span class="line"></span><br><span class="line">add(<span class="number">1</span>,<span class="number">2</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      装饰器
    
    </summary>
    
      <category term="Python" scheme="https://zxyyee.cn/categories/Python/"/>
    
    
      <category term="Python" scheme="https://zxyyee.cn/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Redis</title>
    <link href="https://zxyyee.cn/post/Redis-0.html"/>
    <id>https://zxyyee.cn/post/Redis-0.html</id>
    <published>2016-03-18T11:13:47.000Z</published>
    <updated>2019-09-04T11:27:48.308Z</updated>
    
    <content type="html"><![CDATA[<h3 id="redis输出的持久化"><a href="#redis输出的持久化" class="headerlink" title="redis输出的持久化"></a><code>redis</code>输出的持久化</h3><h3 id="redis的五种数据类型"><a href="#redis的五种数据类型" class="headerlink" title="redis的五种数据类型"></a><code>redis</code>的五种数据类型</h3><h3 id="redis的优势"><a href="#redis的优势" class="headerlink" title="redis的优势"></a><code>redis</code>的优势</h3><h3 id="redis的事务"><a href="#redis的事务" class="headerlink" title="redis的事务"></a><code>redis</code>的事务</h3><h3 id="redis的读写性能"><a href="#redis的读写性能" class="headerlink" title="redis的读写性能"></a><code>redis</code>的读写性能</h3><h3 id="redis的密码"><a href="#redis的密码" class="headerlink" title="redis的密码"></a><code>redis</code>的密码</h3><h3 id="redis、mongo、mysql、oracle的区别"><a href="#redis、mongo、mysql、oracle的区别" class="headerlink" title="redis、mongo、mysql、oracle的区别"></a><code>redis、mongo、mysql、oracle</code>的区别</h3><h3 id="redis中字符串类型的值，最大容纳量是多少"><a href="#redis中字符串类型的值，最大容纳量是多少" class="headerlink" title="redis中字符串类型的值，最大容纳量是多少"></a><code>redis</code>中字符串类型的值，最大容纳量是多少</h3><h4 id="Redis基础知识："><a href="#Redis基础知识：" class="headerlink" title="Redis基础知识："></a><code>Redis</code>基础知识：</h4><p><code>Redis</code>是完全开源免费，遵守BSD协议，是一个高性能的键值数据库，是当前最热门的NoSQL数据库之一，也被称为数据结构服务器。<br><code>Redis</code>内存数据库，速度快，也支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。<br><code>Redis</code>不仅仅支持简单的key-value类型的数据，同时还提供了list、set、zset、hash等数据结构的存储。<br><code>Redis</code>支持数据的备份，即master-slave模式的数据备份。</p><h4 id="Redis支持事务"><a href="#Redis支持事务" class="headerlink" title="Redis支持事务"></a><code>Redis</code>支持事务</h4><p>（BSD协议：BSD开源协议是一个给于使用者很大自由的协议。<br>可以自由的使用，修改源代码，也可以将修改后的代码作为开源或者专有软件再发布。当你发布使用了BSD协议的代码，或者以BSD协议代码为基础做二次开发自己的产品时，需要满足三个条件：<br>如果再发布的产品中包含源代码，则在源代码中必须带有原来代码中的BSD协议。<br>如果再发布的只是二进制类库/软件，则需要在类库/软件的文档和版权声明中包含原来代码中的BSD协议。<br>不可以用开源代码的作者/机构名字和原来产品的名字做市场推广。）</p><h4 id="Redis数据持久化："><a href="#Redis数据持久化：" class="headerlink" title="Redis数据持久化："></a><code>Redis</code>数据持久化：</h4><p><code>Redis</code>的所有数据都是保存在内存中，然后不定期的通过异步方式保存到磁盘上（这称为“半持久化模式”），也可以把每一次数据变化都写到一个append only file(aof)里面（这称为“全持久化模式”）<br>由于<code>Redis</code>的数据都存放在内存中，如果没有配置持久化，<code>Redis</code>重启后数据就全丢失了，于是需要开启<code>Redis</code>的持久化功能，将数据保存到磁盘上，当<code>Redis</code>重启后可以从磁盘中恢复数据。<br><code>Redis</code>提供两种方式进行持久化：<br>RDB持久化<br>将<code>Redis</code>在内存中的数据库记录定时dump到磁盘上的RDB持久化<br>AOF持久化<br>将<code>Redis</code>的操作日志以追加的方式写入文件</p><h4 id="Redis数据类型："><a href="#Redis数据类型：" class="headerlink" title="Redis数据类型："></a><code>Redis</code>数据类型：</h4><p>string（字符串）<br>string是<code>Redis</code>最基本的类型，与<code>Memcached</code>一模一样的类型，一个key对应一个value<br>string类型是二进制安全的，意思是<code>redis</code>的string可以包含任何数据。比如jpg图片或者序列化的对象<br>string类型是<code>Redis</code>最基本的数据类型，string类型的值最大能存储512MB<br>hash（哈希）<br><code>Redis</code> hash是一个键值（key=&gt;value）对集合<br><code>Redis</code> hash是一个string类型的field和value的映射表，hash特别适合用于存储对象<br>list（列表）<br><code>Redis</code>列表是简单的字符串列表，按照插入顺序排序。可以添加一个元素到列表的头部（左边）或者尾部（右边）<br>set（集合）<br><code>Redis</code>的set是string类型的无序集合。<br>集合是通过哈希表实现的，所以添加、删除、查找的复杂度是O(1)<br><code>zset</code>（有序集合）<br><code>Redis</code> <code>zset</code>和set一样也是string类型元素的集合，且不允许重复的成员。<br>不同的是每个元素都会关联一个double类型的分数。<code>Redis</code>正是通过分数来为集合中的成员进行从小到大的排序。<br><code>zset</code>的成员是唯一的，但分数（score）却可以重复</p><h4 id="Redis的读写性能："><a href="#Redis的读写性能：" class="headerlink" title="Redis的读写性能："></a><code>Redis</code>的读写性能：</h4><p>性能极高 -<code>Redis</code>能读的速度是110000/s，写的速度是81000/s 。<br>丰富的数据类型 -<code>Redis</code>支持二进制案例的string,list,hash,set,<code>zset</code>数据类型操作。<br>原子 -<code>Redis</code>的所有操作都是原子性的，同事<code>Redis</code>还支持对几个操作合并后的原子性执行。（事务）<br>丰富的特性 -<code>Redis</code>还支持publish/subscribe，通知，key过期等等特性</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;redis输出的持久化&quot;&gt;&lt;a href=&quot;#redis输出的持久化&quot; class=&quot;headerlink&quot; title=&quot;redis输出的持久化&quot;&gt;&lt;/a&gt;&lt;code&gt;redis&lt;/code&gt;输出的持久化&lt;/h3&gt;&lt;h3 id=&quot;redis的五种数据类型&quot;&gt;&lt;a
      
    
    </summary>
    
      <category term="数据库" scheme="https://zxyyee.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="数据库" scheme="https://zxyyee.cn/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>部署分布式爬虫</title>
    <link href="https://zxyyee.cn/post/%E9%83%A8%E7%BD%B2%E5%88%86%E5%B8%83%E5%BC%8F%E7%88%AC%E8%99%AB.html"/>
    <id>https://zxyyee.cn/post/部署分布式爬虫.html</id>
    <published>2016-01-22T11:14:09.000Z</published>
    <updated>2019-09-04T11:29:20.419Z</updated>
    
    <content type="html"><![CDATA[<p>pip install gerapy<br>配置环境变量：<br>C:\Users\Administrator\AppData\Roaming\Python\Python36\Scripts</p><p><code>gerapy init</code>  初始化工作目录<br><code>cd gerapy</code><br><code>gerapy migrate</code>    迁移生成数据库<br><code>gerapy runserver</code>   启动服务<br><a href="http://127.0.0.1:8000" target="_blank" rel="noopener">http://127.0.0.1:8000</a>  访问界面<br>———Gerapy 管理界面使用——–<br>添加client：连接远程或本机的scrapyd服务（前提是scrapyd处于开启状态）<br>添加Projects：将scarpy项目直接放到 /gerapy/projects，刷新页面</p>]]></content>
    
    <summary type="html">
    
      分布式
    
    </summary>
    
      <category term="爬虫" scheme="https://zxyyee.cn/categories/%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="爬虫" scheme="https://zxyyee.cn/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>FTP和SFTP</title>
    <link href="https://zxyyee.cn/post/FTP%E5%92%8CSFTP.html"/>
    <id>https://zxyyee.cn/post/FTP和SFTP.html</id>
    <published>2016-01-19T22:11:39.000Z</published>
    <updated>2019-09-04T11:28:32.746Z</updated>
    
    <content type="html"><![CDATA[<h2 id="FTP、SFTP"><a href="#FTP、SFTP" class="headerlink" title="FTP、SFTP"></a>FTP、SFTP</h2><blockquote><p>TSL、SSL</p><p>正常模式：需要用户名密码交互，会有权限</p></blockquote><p>FTP:<br>文件传输协议（英文：File Transfer Protocol，缩写：FTP）是用于在网络上进行文件传输的一套标准协议，使用客户/服务器模式。它属于网络传输协议的应用层。文件传送（file transfer）和文件访问（file access）之间的区别在于：前者由FTP提供，后者由如NFS等应用系统提供。<br>FTP是一个8位的客户端-服务器协议，能操作任何类型的文件而不需要进一步处理，就像MIME或Unicode一样。但是，FTP有着极高的延时，这意味着，从开始请求到第一次接收需求数据之间的时间，会非常长；并且不时的必须执行一些冗长的登录进程。</p><p>SFTP:<br>sftp是SSH File Transfer Protocol的缩写，安全文件传送协议。可以为传输文件提供一种安全的网络的加密方法。sftp 与 ftp 有着几乎一样的语法和功能。SFTP 为 SSH的其中一部分，是一种传输档案至 Blogger 伺服器的安全方式。其实在SSH软件包中，已经包含了一个叫作SFTP(Secure File Transfer Protocol)的安全文件信息传输子系统，SFTP本身没有单独的守护进程，它必须使用sshd守护进程（端口号默认是22）来完成相应的连接和答复操作，所以从某种意义上来说，SFTP并不像一个服务器程序，而更像是一个客户端程序。SFTP同样是使用加密传输认证信息和传输的数据，所以，使用SFTP是非常安全的。但是，由于这种传输方式使用了加密/解密技术，所以传输效率比普通的FTP要低得多。</p>]]></content>
    
    <summary type="html">
    
      传输
    
    </summary>
    
      <category term="传输协议" scheme="https://zxyyee.cn/categories/%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE/"/>
    
    
      <category term="协议" scheme="https://zxyyee.cn/tags/%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>Linux775权限</title>
    <link href="https://zxyyee.cn/post/Linux775%E6%9D%83%E9%99%90.html"/>
    <id>https://zxyyee.cn/post/Linux775权限.html</id>
    <published>2015-07-28T11:13:01.000Z</published>
    <updated>2019-09-04T11:28:28.162Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Linux权限：775"><a href="#Linux权限：775" class="headerlink" title="Linux权限：775"></a>Linux权限：775</h3><blockquote><p>rw-    r–    r–</p></blockquote><blockquote><p>文件所有者，文件所属组，其他用户</p><p><img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1557893643709&di=954a84c3de9f257d572cfb57602cd688&imgtype=0&src=http%3A%2F%2Fs3.51cto.com%2Fwyfs02%2FM02%2F6B%2F87%2FwKiom1UvgaKjh86oAAI4Qn18ZeE502.jpg" alt="img"> </p></blockquote>]]></content>
    
    <summary type="html">
    
      Linux
    
    </summary>
    
      <category term="Linux" scheme="https://zxyyee.cn/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://zxyyee.cn/tags/Linux/"/>
    
  </entry>
  
</feed>
