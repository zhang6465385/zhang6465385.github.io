<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>张兴亚的技术博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://zxyyee.cn/"/>
  <updated>2019-09-04T03:20:31.074Z</updated>
  <id>https://zxyyee.cn/</id>
  
  <author>
    <name>Xingya</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>在centos7.6上利用docker-compose统一管理容器和服务</title>
    <link href="https://zxyyee.cn/post/%E5%9C%A8centos7-6%E4%B8%8A%E5%88%A9%E7%94%A8docker-compose%E7%BB%9F%E4%B8%80%E7%AE%A1%E7%90%86%E5%AE%B9%E5%99%A8%E5%92%8C%E6%9C%8D%E5%8A%A1.html"/>
    <id>https://zxyyee.cn/post/在centos7-6上利用docker-compose统一管理容器和服务.html</id>
    <published>2019-09-03T11:26:25.000Z</published>
    <updated>2019-09-04T03:20:31.074Z</updated>
    
    <content type="html"><![CDATA[<p>​    众所周知，一个大型的Docker容器组成的微服务应用中，容器的数量是非常巨大的，如果依赖传统的人工配置方式进行维护，对于开发和运维来说简直就是噩梦。docker-compose的出现正是为了解决这个问题。 </p><p>​    docker-compose是一个用于定义和运行多容器Docker应用的工具，只需要一个Compose的配置文件和一个简单的命令就可以创建并运行应用所需的所有容器。在配置文件中，所有容器通过services来定义，并使用docker-compose命令启动或停止容器以及所有依赖容器。</p><p>如何安装请参照这篇文章:<a href="https://iamhaibei.cn/2019/09/01/%E5%9C%A8Centos7-6%E4%B8%8A%E9%83%A8%E7%BD%B2Docker%E7%8E%AF%E5%A2%83%E4%BB%A5%E5%8F%8A%E5%AE%89%E8%A3%85docker-compose/" target="_blank" rel="noopener">在Centos7.6上部署Docker环境以及安装docker-compose</a> </p><p>我们的目标是：在docker容器内部创建一个基于tornado的web应用服务 </p><p>​    需要注意一点，在 Docker 中有一个由官方提供的中央镜像仓库，不过，由于众所周知的原因，有时它除了慢的可怜以外，还经常莫名其妙的完全无法访问。</p><p>​    在 Linux 环境下，我们可以通过修改 /etc/docker/daemon.json ( 如果文件不存在，你可以直接创建它 ) 这个 Docker 服务的配置文件达到效果,从而将国外的源转向国内，使下载速度和效率提高。  </p><p>​    vim /etc/docker/daemon.json </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;registry-mirrors&quot;: [</span><br><span class="line">        &quot;https://registry.docker-cn.com&quot;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    然后重启docker，令其生效: </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure><p>​    首先需要一个文件夹作为项目文件夹： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir composetest</span><br><span class="line">cd composetest</span><br></pre></td></tr></table></figure><p>​    在项目文件夹下创建一个app.py： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">from  tornado.web import RequestHandler</span><br><span class="line">import tornado.ioloop</span><br><span class="line">import tornado.web</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class IndexHandler(RequestHandler):</span><br><span class="line">    def get(self):</span><br><span class="line">        self.write(&apos;hello world&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def make_app():</span><br><span class="line">    return tornado.web.Application(handlers=[</span><br><span class="line">        (r&apos;/&apos;, IndexHandler)</span><br><span class="line">    ],debug=True)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    app = make_app()</span><br><span class="line">    app.listen(8000)</span><br><span class="line">    tornado.ioloop.IOLoop.current().start()</span><br></pre></td></tr></table></figure><p>​    在项目文件夹下创建一个requirements.txt的文件，这是你的web项目依赖，这里我们只需要一个tornado </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tornado==5.1.1</span><br></pre></td></tr></table></figure><p>​    到此，我们已经完成了新建项目，编码，添加依赖等工作</p><p>​    </p><p>​    下面我们创建一个Dockerfile文件用于构建Docker镜像，该镜像包含了运行该Web应用的所有依赖，包括Python运行环境。</p><p>​     在项目文件夹下创建一个Dockerfile文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FROM python:3.4-alpine</span><br><span class="line">ADD . /code</span><br><span class="line">WORKDIR /code</span><br><span class="line">RUN pip install -r requirements.txt</span><br><span class="line">CMD [&quot;python&quot;, &quot;app.py&quot;]</span><br></pre></td></tr></table></figure><p>​    上面的命令的意思是：</p><p>​    使用python-3.4-alpine作为基础镜像<br>    将当前目录添加到镜像中/code目录下<br>    将/code设置为工作目录<br>    安装Python依赖<br>    设置默认执行命令</p><p>​    在项目文件夹下创建一个docker-compose.yml文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">version: &apos;2.0&apos;</span><br><span class="line">services:</span><br><span class="line">  web:</span><br><span class="line">    build: .</span><br><span class="line">    ports:</span><br><span class="line">     - &quot;8000:8000&quot;</span><br><span class="line">    volumes:</span><br><span class="line">     - .:/code</span><br></pre></td></tr></table></figure><p>​    该配置文件中包含一个services，即web服务。web会使用当前目录中的Dockerfile文件构建镜像，并将容器的8000端口暴露给主机，然后将项目文件夹挂载到容器中的/code目录下</p><p>​    至此，所有配置都已经弄好了，项目结构如下：</p><p><img src="https://v3u.cn/v3u/Public/js/editor/attached/image/20190902/20190902092915_82650.png" alt="img"> </p><p>执行命令运行容器，则docker-compose将会根据docker-file所写的脚本一键构建web应用的镜像以及启动容器 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker-compose up</span><br></pre></td></tr></table></figure><p> 此时，访问localhost:8000 </p><p><img src="https://v3u.cn/v3u/Public/js/editor/attached/image/20190902/20190902093114_96444.png" alt="img"> </p><p>​    说明我们构建的镜像已经运行起来，如此一来，我们只需要关注代码逻辑的编写，而不用考虑环境的搭建了，环境只需要依赖docker帮我们做就好了。</p><p>​    上面提到的Componse使用命令构建并启动容器，是以前台的方式启动的，如果希望以后台启动，可以添加参数-d，比如下面这样</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker-compose up -d</span><br></pre></td></tr></table></figure><p>​    而且可以查看目前正在运行的容器，有点类似docker-ps </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose ps</span><br></pre></td></tr></table></figure><p><img src="https://v3u.cn/v3u/Public/js/editor/attached/image/20190902/20190902094032_18479.png" alt="img"> </p><p>​    如果使用sudo docker-compose up -d命令以后台方式启动，可以用docker-compose stop命令停止。docker-compose down 命令可以停止容器并将其删除。</p><p>​        有关Compose的更多命令，可以通过sudo docker-compose –help查看</p><p>​        可以发现，docker-compose将docker run命令整合到了一个docker-compose.yml配置文件中，对于大型Docker集群的管理是很方便的，例可以将多个service组合成更复杂的service组，为每个service指定不同的Dockerfile，然后把它们link在一起。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;​    众所周知，一个大型的Docker容器组成的微服务应用中，容器的数量是非常巨大的，如果依赖传统的人工配置方式进行维护，对于开发和运维来说简直就是噩梦。docker-compose的出现正是为了解决这个问题。 &lt;/p&gt;
&lt;p&gt;​    docker-compose是一
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>在Centos7.6上部署Docker环境以及安装docker-compose</title>
    <link href="https://zxyyee.cn/post/%E5%9C%A8Centos7-6%E4%B8%8A%E9%83%A8%E7%BD%B2Docker%E7%8E%AF%E5%A2%83%E4%BB%A5%E5%8F%8A%E5%AE%89%E8%A3%85docker-compose.html"/>
    <id>https://zxyyee.cn/post/在Centos7-6上部署Docker环境以及安装docker-compose.html</id>
    <published>2019-09-01T12:32:11.000Z</published>
    <updated>2019-09-03T11:45:59.169Z</updated>
    
    <content type="html"><![CDATA[<p>​    毫无疑问，<strong>Docker</strong>目前是现阶段最为火爆的容器技术了，它在业务解耦和拆分业务层面有着不可忽视的作用，而使用 <strong>Docker Compose</strong> 可以轻松、高效的管理容器，它是一个用于定义和运行多容器 Docker 的应用程序工具，这里记录一下如何在centos7.6上部署Docker以及docker-compose。 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#升级yum</span></span><br><span class="line">sudo yum update</span><br><span class="line"><span class="comment">#卸载旧版本docker</span></span><br><span class="line">sudo yum remove docker  docker-common docker-selinux docker-engine</span><br><span class="line"><span class="comment">#安装依赖</span></span><br><span class="line">sudo yum install -y yum-utils device-mapper-persistent-data lvm2</span><br><span class="line"><span class="comment">#设置源</span></span><br><span class="line">sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line">sudo yum makecache fast</span><br><span class="line"><span class="comment">#安装docker</span></span><br><span class="line">sudo yum install docker-ce</span><br><span class="line"><span class="comment">#启动服务</span></span><br><span class="line">sudo systemctl start docker</span><br><span class="line"><span class="comment">#查看版本</span></span><br><span class="line">docker version</span><br><span class="line"><span class="comment">#拉取镜像</span></span><br><span class="line">docker pull hello-world</span><br><span class="line"><span class="comment">#启动容器</span></span><br><span class="line">docker run hello-world</span><br></pre></td></tr></table></figure><p>启动容器后，如果出现下面的输出则表示安装成功 </p><p><img src="https://v3u.cn/v3u/Public/js/editor/attached/image/20190821/20190821094924_49629.png" alt="img"> </p><p>下面安装docker-compose，运行下面的脚本可以自动安装，并且授权 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo curl -L https://github.com/docker/compose/releases/download/1.21.2/docker-compose-$(uname -s)-$(uname -m) -o /usr/local/bin/docker-compose</span><br><span class="line">sudo chmod +x /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure><p>安装成功后，检查版本号 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose -v</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;​    毫无疑问，&lt;strong&gt;Docker&lt;/strong&gt;目前是现阶段最为火爆的容器技术了，它在业务解耦和拆分业务层面有着不可忽视的作用，而使用 &lt;strong&gt;Docker Compose&lt;/strong&gt; 可以轻松、高效的管理容器，它是一个用于定义和运行多容器 
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>个人简历</title>
    <link href="https://zxyyee.cn/post/%E4%B8%AA%E4%BA%BA%E7%AE%80%E5%8E%86.html"/>
    <id>https://zxyyee.cn/post/个人简历.html</id>
    <published>2019-09-01T11:13:24.000Z</published>
    <updated>2019-09-04T11:29:33.769Z</updated>
    
    <content type="html"><![CDATA[<p>张兴亚</p><p>Python全栈开发工程师</p><p>4年工作经验                           </p><p>Tel：155-4652-3383</p><p>Email：<a href="mailto:zhangxingya9@gmail.com" target="_blank" rel="noopener">zhangxingya9@gmail.com</a> </p><p>个人博客：zxyyee.cn</p><hr><h3 id="教育经历"><a href="#教育经历" class="headerlink" title="教育经历"></a>教育经历</h3><p>2011.09-2015.06                  东北林业大学                           统招本科</p><hr><h3 id="个人介绍"><a href="#个人介绍" class="headerlink" title="个人介绍"></a>个人介绍</h3><p>四年Python全栈开发经验，参与设计并开发过多个项目，负责系统核心模块的开发，熟练掌握<strong>各种Python框架</strong>，熟练使用<strong>Docker</strong>，使用<strong>Docker-compose</strong>批量管理容器集群，<strong>Docker-fil</strong>e编写部署脚本，并采用<strong>RollingUpdat</strong>e升级容器。利用<strong>Redisearch</strong>进行全文检索。熟悉前端业务规范，掌握<strong>vue.js</strong>开发，熟悉响应式开发框架<strong>Bootstrap</strong>，<strong>flex弹性布局</strong>，了解<strong>微服务架构</strong>，掌握<strong>RPC</strong>协议，熟练使用<strong>Thrift</strong>框架，对算法和数据结构有独到的见解。有<strong>高并发WEB应用</strong>架构的能力。有利用<strong>mpvue</strong>框架开发微信小程序的经验。具备优秀的学习能力和团队沟通能力，经常与团队进行技术分享，能与团队共同成长。</p><hr><h3 id="专业技能"><a href="#专业技能" class="headerlink" title="专业技能"></a>专业技能</h3><p>后端框架：Tornado，Django，Thrift ，Celery，Sanic，Flask</p><p>前端框架：Node.js，Vue.js，Bootstrap，Mpvue，React</p><p>数据库：Mysql，Mongodb ，Redis</p><p>工具：Docker，Postman，VSCode</p><p>其他：Fastdfs ， Websocket， Quill-Edior，RabbitMQ，SuperVisor</p><hr><h3 id="工作经历"><a href="#工作经历" class="headerlink" title="工作经历"></a>工作经历</h3><p>l  2017年2月 - 至今          百度糯米 — Python高级全栈开发工程师</p><p>l  2015年6月 - 2017年2月 北京医视时代科技发展有限公司 — 初级python开发工程师</p><hr><h3 id="项目经验"><a href="#项目经验" class="headerlink" title="项目经验"></a>项目经验</h3><h4 id="美食团购"><a href="#美食团购" class="headerlink" title="美食团购"></a>美食团购</h4><p>*<em>项目描述: *</em></p><p>B2C网站，通过线上中介的方式，将商家和用户联系起来。团购网站与商家合作，签订一定人数规模的顾客和一定的商家折扣。在线预订、在线支付。根据客户对商家环境或食品质量等的评价，对每个商家进行分数评估。</p><p>项目职责：支付模块、情感分析、技术优化、运维工作</p><p><strong>技术要点：</strong></p><p>•  项目的大规模服务采用 <strong>Docker</strong> 进行部署，隔离服务；项目采用使用 Mysql 数据库存储数据，配置<strong>主从同步</strong>，缓解数据库压力。</p><p>•      采用<strong>Celery</strong>和<strong>Rabbitmq</strong>异步任务队列架构，同时配置自动化定时任务</p><p>•   利用<strong>gensim</strong> 对商家评论进行分析，区分正反面评价。进行商家分数评估。</p><p>•   使用 <strong>Redis</strong> 搭建集群，解决高并发。</p><p>•   利用 <strong>Websocket</strong> 实现实时消息推送。</p><p>•   三方支付使用在线支付接口，封装支付宝，微信等第三方支付平台。</p><p>•   后期使用 <strong>Thrift</strong> 框架 <strong>RPC</strong> 协议架构对传统的 http 接口进行重构，提高了整体接口的<strong>性能和吞吐量</strong>。</p><p>•      利用 <strong>Nginx</strong> 反向代理后台<strong>Tornado</strong>接口，并且针对性使用 Nginx <strong>负载均衡</strong>策略。</p><p>•      使用<strong>Supervisor</strong>来监控服务器进程，自动回复进程，简化服务操作。<strong>降低了日常维护成本</strong>。</p><h4 id="管理信息系统"><a href="#管理信息系统" class="headerlink" title="管理信息系统"></a>管理信息系统</h4><p><strong>项目描述：</strong></p><p>公司内部使用的管理系统，针对员工的管理系统，规范流程，随时监控流程进度，减少了人为的失误，使信息安全得到保障。项目模块：流程协作类管理，人事行政类管理。</p><p><strong>项目职责</strong>：</p><p>流程协作类管理：流程审批、费用管理、任务管理   </p><p>人事行政类管理：考勤管理、假期管理</p><p><strong>技术要点：</strong></p><p>• 集成<strong>RBAC</strong>权限管理系统，方便管理层权限管理及责任划分。</p><p>• 搭建基于<strong>Task</strong> 的任务计划管理， 对计划任务进行配置和管理。</p><p>• 构建假期管理， 随时了解办理进度，让出差、请假申请过程变得可控，同时关联人事考勤。</p><p>• 采用<strong>Bootstrap</strong>响应式设计前端框架，方便领导随时审批和查看平台状况。</p><p>####<strong>医学知识库</strong> </p><p><strong>项目详情：</strong></p><p>医学知识库是集医学数据库群、医学图书库、医学图片库以及教学资源库等医学资源于一体，是一套庞大的医学类知识库系统。主要功能：医学数据库群、医学图书库、医学图片库，评论回复等模块。</p><p>项目职责：评论回复、精准搜索推荐、数据存储，消息推送</p><p><strong>技术要点：</strong></p><p>•  利用<strong>Websocket</strong>实现后端消息主动推送，改造前端传统轮询技术框架，减少网络请求数，节约可用带宽。</p><p>•  利用<strong>fastdfs</strong>对几十万医学图片静态资源进行去重存储。</p><p>•  利用ElasticSearch进行知识搜索,后续维护时因其运行时内存有着最低限额，改用<strong>Redisearch</strong>打造全文检索引擎。</p><p>•  使用<strong>协同过滤算法</strong>实现精准推荐，人性化推荐，提高用户体验。</p><p>•  通过 <strong>Echart</strong> 实现数据可视化。</p><p>•  通过<strong>Supervisor</strong> 管理服务进程。</p><hr><h3 id="兴趣与奖项"><a href="#兴趣与奖项" class="headerlink" title="兴趣与奖项"></a>兴趣与奖项</h3><p>大学期间参加辩论赛担任三辩，进入半决赛。</p><p>大学期间获得全国计算机竞赛二等奖。</p><p>活跃在各种技术论坛，热衷解决问题和探索。</p><p>代表公司受邀参加百度开发者大会学习和交流。</p>]]></content>
    
    <summary type="html">
    
      个人简历
    
    </summary>
    
      <category term="个人简历" scheme="https://zxyyee.cn/categories/%E4%B8%AA%E4%BA%BA%E7%AE%80%E5%8E%86/"/>
    
    
  </entry>
  
  <entry>
    <title>使用python3和高性能全文检索引擎Redisearch进行交互</title>
    <link href="https://zxyyee.cn/post/%E4%BD%BF%E7%94%A8python3%E5%92%8C%E9%AB%98%E6%80%A7%E8%83%BD%E5%85%A8%E6%96%87%E6%A3%80%E7%B4%A2%E5%BC%95%E6%93%8ERedisearch%E8%BF%9B%E8%A1%8C%E4%BA%A4%E4%BA%92.html"/>
    <id>https://zxyyee.cn/post/使用python3和高性能全文检索引擎Redisearch进行交互.html</id>
    <published>2019-08-30T12:02:35.000Z</published>
    <updated>2019-09-04T03:20:52.959Z</updated>
    
    <content type="html"><![CDATA[<p>​    上一篇介绍了一款<a href="https://iamhaibei.cn/2019/08/28/%E4%BD%BF%E7%94%A8Redisearch%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%85%A8%E6%96%87%E6%A3%80%E7%B4%A2%E5%8A%9F%E8%83%BD%E6%9C%8D%E5%8A%A1/" target="_blank" rel="noopener">高性能全文检索引擎Redisearch</a>，它不仅性能强劲，部署也方便，这里介绍一下如何用python客户端和它进行交互。</p><p>​    首先，安装 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install redisearch</span><br></pre></td></tr></table></figure><p> 基本操作: </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">from redisearch import Client, TextField</span><br><span class="line"># Creating a client with a given index name</span><br><span class="line">client = Client(&apos;myIndex&apos;,host=&apos;localhost&apos;,port=&apos;6666&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Creating the index definition and schema</span><br><span class="line">client.create_index((TextField(&apos;title&apos;), TextField(&apos;body&apos;)))</span><br><span class="line"></span><br><span class="line"># Indexing a document</span><br><span class="line">client.add_document(&apos;doc2&apos;, title = &apos;你好&apos;, body = &apos;我叫海北，我在北京&apos;,language=&apos;chinese&apos;)</span><br><span class="line"></span><br><span class="line"># Simple search</span><br><span class="line">res = client.search(&quot;海北&quot;)</span><br><span class="line"></span><br><span class="line">print(res.docs[0].title)</span><br></pre></td></tr></table></figure><pre><code>可以看到，基本上和命令行中的操作方式没有太大区别，只是在search时不需要指定语言了，程序可以自主判断。</code></pre><p>​    其实它的官方文档很简单，只是介绍了基本用法，但是你如果阅读了它的源码，发现一些常用操作它也进行了封装，比如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#删除索引</span><br><span class="line">client.drop_index()</span><br><span class="line"></span><br><span class="line">#获取当前索引的基本信息</span><br><span class="line">client.info()</span><br><span class="line"></span><br><span class="line">#删除文档</span><br><span class="line">client.delete_document(&apos;doc2&apos;)</span><br></pre></td></tr></table></figure><p>​    还是非常简单的，基本上，我们可以抛弃ES了，因为研发人员都是喜新厌旧的。 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;​    上一篇介绍了一款&lt;a href=&quot;https://iamhaibei.cn/2019/08/28/%E4%BD%BF%E7%94%A8Redisearch%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%85%A8%E6%96%87%E6%A3%80%
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>使用Redisearch实现的全文检索功能服务</title>
    <link href="https://zxyyee.cn/post/%E4%BD%BF%E7%94%A8Redisearch%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%85%A8%E6%96%87%E6%A3%80%E7%B4%A2%E5%8A%9F%E8%83%BD%E6%9C%8D%E5%8A%A1.html"/>
    <id>https://zxyyee.cn/post/使用Redisearch实现的全文检索功能服务.html</id>
    <published>2019-08-28T15:12:18.000Z</published>
    <updated>2019-09-03T12:00:08.095Z</updated>
    
    <content type="html"><![CDATA[<p>​    “检索”是很多产品中无法绕开的一个功能模块，当数据量小的时候可以使用模糊查询等操作凑合一下，但是当面临海量数据和高并发的时候，业界常用 elasticsearch 和 lucene 等方案，但是elasticsearch对运行时内存有着最低限额，其运行时大小推荐 2G 以上的内存空间，并且需要额外的磁盘空间做持久化存储。</p><p>​    其实mongoDB 内置的正则匹配搜索文本以及自带的 text 索引和 search 关键字也是一套靠谱的解决方案，但是这一次我们带来一种更加高效经济的文本检索方案：Redisearch</p><p>​    下图是elasticsearch和redisearch的性能对比</p><p><img src="https://v3u.cn/v3u/Public/js/editor/attached/image/20190829/20190829025837_90896.png" alt="img"> </p><p>​    Redis Modules 是 redis 4.0 引入的一种扩展机制，用户可以通过实现 redis module 提供的 C api 接口为 redis 服务添加定制化功能。 redisLab 也希望籍此来规范 redis 社区的 ecosystem 实现。      </p><p>​    redis module 本身的版本独立于redis，并且以编译成动态加载库 .so 文件的方式 release， 不同版本的 redis 可以 load 同一版本 module.so 文件。      </p><p>​    redis 提供了两种加载方式。可以通过 在 conf 文件中 加入 loadmodule /path/to/mymodule.so ，也可以在 redis-cli中使用命令 MODULE LOAD /path/to/panda.so 动态加载，MODULE UNLOAD 卸载。 </p><p>​    <strong>特性</strong>      </p><p>基于文档的全文索引。     </p><p>高性能增量索引。     </p><p>支持文档评分，文档字段(field) 权重机制。     </p><p>支持布尔复杂查询。     </p><p>支持自动补全。     </p><p>基于 snowball 的词干分析，多语言支持。</p><p>使用 friso 支持中文分词。     </p><p>utf-8 字符集支持。     </p><p>redis 数据持久化支持。     </p><p>自定义评分机制。 </p><p>​    其原理是在 redis 的 hashmap 基础上就可以很容易实现倒排索引的结构。redisearch 倒排索引除了实现了基础功能外，还引入了内存管理等优化功能。如果有兴趣可以阅读源码中的 src/inverted_index.c 部分 </p><p>​    首先，安装Rediseach,记住一点你本地的redis服务版本必须在4.0以上，网上一大堆编译安装的攻略，繁琐又浪费时间，所以又到了Docker登场时间了，hub上有编译好的免费镜像供我们下载 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull redislabs/redisearch</span><br></pre></td></tr></table></figure><p>​    下载后，直接在后台启动服务 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 6666:6379 redislabs/redisearch:latest</span><br></pre></td></tr></table></figure><p><img src="https://v3u.cn/v3u/Public/js/editor/attached/image/20190829/20190829025426_73540.png" alt="img"> </p><p>​    此时已经有一个docker容器在后台启动了，redis服务映射到了宿主的6666端口，我们来连接一下 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -h localhost -p 6666</span><br></pre></td></tr></table></figure><p><img src="https://v3u.cn/v3u/Public/js/editor/attached/image/20190829/20190829023916_11652.png" alt="img"> </p><p>​    检查 modules 是否成功加载 </p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">localhost:<span class="number">6666</span>&gt; MODULE list</span><br><span class="line"><span class="number">1</span>) <span class="number">1</span>) <span class="string">"name"</span></span><br><span class="line">   <span class="number">2</span>) <span class="string">"ft"</span></span><br><span class="line">   <span class="number">3</span>) <span class="string">"ver"</span></span><br><span class="line">   <span class="number">4</span>) (integer) <span class="number">10405</span></span><br></pre></td></tr></table></figure><p>​    如果返回数组中存在 “ft” ， 则表明 redisearch 已经成功加载。 </p><p>​    Redisearch 的索引概念 与elasticsearch 的 index 类似，表示某一类文档资源单元。 </p><p>​    这里我们定义了一个 SMARTX_VM 索引，其中存储的文档 包含 了 title 和 desc 两个 类型为 TEXT 的field。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FT.CREATE SMARTX_VM SCHEMA title TEXT WEIGHT 5.0 desc TEXT</span><br></pre></td></tr></table></figure><p>​    然后向刚刚创建的这条索引加一个文档 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FT.ADD SMARTX_VM vm-2019082911110001 1.0 LANGUAGE &quot;chinese&quot; FIELDS title &quot;海北&quot; desc &quot;我叫海北，我在北京，海北是我的艺名&quot;</span><br></pre></td></tr></table></figure><p>​    LANGUAGE “chinese” 参数 表示 使用 中文分词器 处理文本。默认为英文</p><p>​        此时我们进行文档检索</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FT.SEARCH SMARTX_VM &quot;海北&quot; LANGUAGE &quot;chinese&quot;</span><br></pre></td></tr></table></figure><p>​    注意检索的时候也要指定语言，这里我们用中文分词，默认的英文分词是无法检索中文的 </p><p>​    <strong>Redisearch</strong> 是一个高效，功能完备的内存存储的高性能全文检索组件， 十分适合应用在数据量适中， 内存和存储空间有限的环境。借助数据同步手段，我们可以很方便的将<strong>redisearch</strong> 结合到现有的数据存储中， 进而向产品提供 全文检索， 自动补全等服务优化功能。 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;​    “检索”是很多产品中无法绕开的一个功能模块，当数据量小的时候可以使用模糊查询等操作凑合一下，但是当面临海量数据和高并发的时候，业界常用 elasticsearch 和 lucene 等方案，但是elasticsearch对运行时内存有着最低限额，其运行时大小推荐 
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>vue打包cookie失效</title>
    <link href="https://zxyyee.cn/post/vue%E6%89%93%E5%8C%85cookie%E5%A4%B1%E6%95%88.html"/>
    <id>https://zxyyee.cn/post/vue打包cookie失效.html</id>
    <published>2019-08-27T18:13:24.000Z</published>
    <updated>2019-09-04T11:29:15.101Z</updated>
    
    <content type="html"><![CDATA[<h3 id="vue打包cookie失效"><a href="#vue打包cookie失效" class="headerlink" title="vue打包cookie失效"></a>vue打包cookie失效</h3><p>​    在写vue时，购物车等功能用到了js.cookie模块。dist打包之后发现cookie失效。</p><p>将所有js.cookie改成Local Storage之后，问题解决。</p><p>​    别忘了存Local Storage的时候，要将内容json.stringify一下。</p>]]></content>
    
    <summary type="html">
    
      js.cookie失效导致浪费了很多时间
    
    </summary>
    
      <category term="Vue" scheme="https://zxyyee.cn/categories/Vue/"/>
    
    
      <category term="Vue" scheme="https://zxyyee.cn/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>MySQL主从分离</title>
    <link href="https://zxyyee.cn/post/MySQL%E4%B8%BB%E4%BB%8E%E5%88%86%E7%A6%BB.html"/>
    <id>https://zxyyee.cn/post/MySQL主从分离.html</id>
    <published>2019-08-25T10:24:13.000Z</published>
    <updated>2019-09-18T07:35:09.610Z</updated>
    
    <content type="html"><![CDATA[<h3 id="引入："><a href="#引入：" class="headerlink" title="引入："></a>引入：</h3><p>   数据业务层、数据访问层，如果还是传统的数据结构，或者只是单单靠一台服务器负载，如此多的数据库连接操作，数据库必然会崩溃，数据库如果宕机的话，后果更是不堪设想。这时候，我们会考虑如何减少数据库的连接，一方面采用优秀的代码框架，进行代码的优化，采用优秀的数据缓存技术如：redis,如果资金丰厚的话，必然会想到架设mysql服务集群，来分担主数据库的压力。今天总结一下利用MySQL主从配置，实现读写分离，减轻数据库压力。</p><h3 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h3><p>   mysql主从同步的原理很简单，从库生成两个线程，一个I/O线程，一个SQL线程；i/o线程去请求主库 的binlog（二进制日志），并将得到的binlog日志写到relay log（中继日志） 文件中；主库会生成一个 log dump 线程，用来给从库 i/o线程传binlog。SQL 线程，会读取relay log文件中的日志，并解析成具体操作，来实现主从的操作一致，而最终数据一致。</p><h3 id="操作："><a href="#操作：" class="headerlink" title="操作："></a>操作：</h3><p>首先准备两台阿里云服务器，一台作为主机(master)，一台作为从机(slave)，都安装好mysql5.7，具体怎样安装mysql服务请移步：<a href="https://v3u.cn/a_id_72" target="_blank" rel="noopener">https://v3u.cn/a_id_72</a></p><p>主机配置：</p><p>修改mysql配置文件 vim /etc/my.cnf</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">server-id=1</span><br><span class="line">innodb_flush_log_at_trx_commit=2</span><br><span class="line">sync_binlog=1</span><br><span class="line">log-bin=mysql-bin-1</span><br></pre></td></tr></table></figure><p>以上配置信息说明：</p><p>设置主服务 的ID (id可以自己随便设置但是要保证和slave的id不一样)</p><p>server-id=1</p><p>设为1当然是最安全的，但性能也是最差的（相对其他两个参数而言，但不是不能接受）。如果对数据一致性和完整性要求不高，完全可以设为2，如果只最求性能，例如高并发写的日志服务器，设为0来获得更高性能</p><p>innodb_flush_log_at_trx_commit=2</p><p>开启binlog 志同步功能</p><p>sync_binlog=1 </p><p>binlog 日志文件名</p><p>log-bin=mysql-bin-200 </p><p>这个表示只同步某个库 (如果没有此项，表示同步所有的库)</p><p>binlog-do-db=xxxx </p><p>保存后启动mysql：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart mysqld</span><br></pre></td></tr></table></figure><p>进入mysql命令行 mysql -uroot -p你的密码</p><p>输入授权命令：（意思是所有slave都可以通过账号repl和密码Admin123!来同步master的数据）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GRANT REPLICATION SLAVE ON *.* to &apos;repl&apos;@&apos;%&apos; identified by &apos;Admin123!&apos;;</span><br></pre></td></tr></table></figure><p>然后查看master的状态:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show master status;</span><br></pre></td></tr></table></figure><p><img src="data:image/png;base64,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HBKalDSpEElCaFBEqEwJUZdrlr8hJES5XCIS4pq6MqVUShPKUMaiRKF0MzdIFGX/n9+qdZxz3r332We/Z35/6/NZZw9retZ3rb33s5+11j6lRMRRT0cCJEACJEACJEACJEACgQiUDhSLkUiABEiABEiABEiABEhgBwEqkOwKJEACJEACJEACJEACSRGgApkULkYmARIgARIgARIgARKgAsk+QAIkQAIkQAIkQAIkkBQBKpBJ4WJkEiABEiABEiABEiABKpDsAyRAAiRAAiRAAiRAAkkRoAKZFC5GJgESIAESIAESIAESoALJPkACJEACJEACJEACJJAUgTIae2h0ilKlSombj46Tyf3GjRtLhw4dpEqVKrJmzRpTdNWqVaVLly7y9ddfy7Zt2wKLU69ePTniiCOkSZMmstdee8lXX30VOG2iiG5yJkqTrnA3WQ488EDTrhs3bixSbBCebnkWycjjRO3ataVr167SuXNnqVu3rnz66aceMcOfDlIHt9zT2SfcysM5t+sL57Ll3NrWr78EkdMtzyDpMhUnG+0epm5h+3WYsgotzT777CMnn3yyfPDBB4VWNdaHBHKCQIwFcvz48fLWW2+5+vLly2dF4BYtWsi1114rxx57bKR8KH84V7169ci5IDv2hjJw4EC5+OKLgyQJHMdNzsCJUxzRTRYo3P/617+kTBm8M8S6IDzd8ozNxf1o7733lscff1z69u0r2D/mmGPcIxbzbJA6uBWRzj7hVl6+XGN+/cWtXvHnwvaX8847T5o1axafXcqPM93uQSrgVvew/TpIefkSx41LENkPPfRQOfvsswVKeCZcWDn9ZAubZ9h0frKEDcslWcLWgencCcQokFdeeaWcdtppcumll5rY99xzjznGuc2bN7vnkOazX3zxhSlh+fLlxS5p9uzZ5oaCh3iqXSrlLK5sbrLcf//9RuE+44wzQmXvlmeQjLp37y6bNm0y/Qj964ILLgiSLGNx0tkn3CqRL9dYtvpL7969Zb/99nNDl9JzmW73IMJnqu5BZMmlOGG5PPXUU2akasOGDRmpTlg5/YQLm2fYdH6yhA3LJVnC1oHp3AmUjT5th4itsvjdd9+ZYWLEGTx4sFFArrvuukiSww8/XAYMGCB42MCiN3z4cLnoooukYcOGMnnyZBk7dqz89ddfUqlSJbn88svl4IMPlq1btwoU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tN1+++1GUVPro6PWV2evvfZy6tSpE6l/IlmCXCtBZIFxYvLkyUaZhe5RpkwZJxklPpGcfsySuYf45ZNvYSmdA/n777/Lzz//rAz+dhieufXWW82JzZs3y/nnn/93YII9fQiIPoDk4IMPlq1bt4pasUTfLhKkys9gr/mPqE2uDGGHIfvLL7/IN998Y/ypp54q++67ff3w/vvvL3rDlfr168v3338vTz31lEybNs0UgaGH008/XVTpkD///NP8H/uVV15ppjx49SW9ackee+wh5cqVk4YNG0rbttsHfT///HOpVq2abx/0kgX53HzzzXL33XfL2WefLfqGKQsXLhRVUkx/DMKjzKZNQaJF4uzyySdy99y5stsWzGBMzq0oX17mXHON3HfooYHl9Ko7StYbsKglQdq3by+77rqr/Prrr/L888+LvuwlFGzdunXy6aefGo9hra5du8rHH38sfuUlytQtTx3BMMk2bNggy5YtM+Ude+yxgr8WS6dzK8/vXlecvuTHLGwb4T6tD9wIu+j7tleeixYt8r0e/OS88MILRRVU+e6776Rnz55mmPOhhx4y9/Pi3OdzqU9s0ms9miPgdu/eXfr27Sv333+/vPvuu+YehnvKhAkTZOrUqeJXd7SDvlSYPHRER1atWmXSffvtt3LVVVeZZ+mWHfeJ0aNHy4svvmiuAa/7IPpsovKir/cgQ9GqKAuGl++991557z18XExk9erVZluce3J8HwwiCwpVZVR0lNNc/9u2bTP9zQijP15195MTzOi8CXjOgfRO4h2ChujSpUvE44aBC+rJJ5+UJUuWCOYlJOOGDx9ulEfcaN555x3RIVBRK0MyWeRNXD8FshC+AVm3bl2jLH744YdGGcENB3OF7rrrLqNc3njjjaat0WCXXXaZ6JujUdQQ74MPMAtQfPsS+t0NN9wg5VWJgrKCfXgofX59EIqRlyyY04M+O2rUKKPIPv3006LDjdK5c2cjT5Cf2v/9rzQMqAyeow+gZoMGhVIeNzZvLj++8IKs15euoHL61R11w0NKh3VkzZo1ggcUHmK1atUKUu2YOHjwof0TlReTKMGBzdNGw4vJSSedJBdccIE888wzgpfZdDq38vz6Wdi+lIhZqtoompVXnn51SCSnWqSMInXuuefKjBkzBIofHvRwqbrP50KfsM8/+wKrVi35448/jOKNF4zb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" alt="avatar"></p><p>记录值，从库连接时使用：</p><p>从机配置：</p><p>修改slave服务器的mysql配置 vim /etc/my.cnf 加入下面的配置，需要注意的是server-id不要和master一样</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">server-id=201 </span><br><span class="line">innodb_flush_log_at_trx_commit=2 </span><br><span class="line">sync_binlog=1 </span><br><span class="line">log-bin=mysql-bin-201</span><br></pre></td></tr></table></figure><p>保存后重启服务 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart mysqld</span><br></pre></td></tr></table></figure><p>进入mysql命令行 mysql -uroot -p你的密码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">change master to master_host=&apos;39.106.228.179&apos;,master_user=&apos;repl&apos; ,master_password=&apos;Admin123!&apos;, master_log_file=&apos;mysql-bin.000002&apos; ,master_log_pos=154</span><br></pre></td></tr></table></figure><p>命令说明：</p><p>master_host: 主机的ip</p><p>master_user : 主机授权的用户.</p><p>master_password : 主机授权时候填写的密码</p><p>master_log_file : 主机show master status;中的File</p><p>master_log_pos: 主机show master status;中的Position.</p><p>输入命令启动slave</p><p>start slave;</p><p>可以查看slave的状态:</p><p>show slave status \G</p><h3 id="错误解决办法："><a href="#错误解决办法：" class="headerlink" title="错误解决办法："></a>错误解决办法：</h3><p>mysql主从同步Slave_SQL_Running: No,Last_Errno: 1062的解决方法</p><ul><li><p>解决办法一：</p></li><li><ul><li>修改mysql的配置文件，/etc/my.cnf，在[mysqld]下面添加一行slave_skip_errors = 1062</li><li>注：</li><li><ul><li>Last_Errno报错1008时也可解决，亲测有效</li></ul></li></ul></li><li><p>解决办法二：</p></li><li><ul><li><p>手动同步：</p><p>change master to</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">master_host=&apos;106.13.139.108&apos;,</span><br><span class="line"></span><br><span class="line">master_user=&apos;repl&apos;,</span><br><span class="line"></span><br><span class="line">master_password=&apos;Admin123!&apos;,</span><br><span class="line"></span><br><span class="line">master_port=3306,</span><br><span class="line"></span><br><span class="line">master_log_file=&apos;mysql-bin-1.000003&apos;,</span><br><span class="line"></span><br><span class="line">master_log_pos=1101;</span><br></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;引入：&quot;&gt;&lt;a href=&quot;#引入：&quot; class=&quot;headerlink&quot; title=&quot;引入：&quot;&gt;&lt;/a&gt;引入：&lt;/h3&gt;&lt;p&gt;   数据业务层、数据访问层，如果还是传统的数据结构，或者只是单单靠一台服务器负载，如此多的数据库连接操作，数据库必然会崩溃，数据库
      
    
    </summary>
    
      <category term="数据库" scheme="https://zxyyee.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="mysql" scheme="https://zxyyee.cn/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>使用flex弹性布局来为微信小程序写自适应页面</title>
    <link href="https://zxyyee.cn/post/%E4%BD%BF%E7%94%A8flex%E5%BC%B9%E6%80%A7%E5%B8%83%E5%B1%80%E6%9D%A5%E4%B8%BA%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%86%99%E8%87%AA%E9%80%82%E5%BA%94%E9%A1%B5%E9%9D%A2.html"/>
    <id>https://zxyyee.cn/post/使用flex弹性布局来为微信小程序写自适应页面.html</id>
    <published>2019-08-10T12:44:20.000Z</published>
    <updated>2019-09-04T10:50:29.191Z</updated>
    
    <content type="html"><![CDATA[<p>​    我们知道，写习惯了前端的人，一般切图后布局页面的话，上手最习惯的是基于盒子模型的浮动布局，依赖 display 属性 + position属性 + float属性，但是浮动布局有一些致命的小问题，比如垂直居中比较费劲，比如著名的<a href="https://v3u.cn/a_id_18" target="_blank" rel="noopener">float坍塌问题</a>，另外有些极端情况下，还得使用模型+clear:both来手动清除浮动，比较麻烦。</p><p>​    于是，W3C 提出了一种新的方案—-Flex 布局，可以简便、完整、响应式地实现各种页面布局。目前，它已经得到了所有浏览器的支持，这意味着，现在就能很安全地使用这项功能，本人在微信小程序页面中尝试了一下弹性布局，个人感觉是：简直太好用了。</p><p>​    Flex 是 Flexible Box 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。</p><p>​    任何一个容器都可以指定为 Flex 布局。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.box&#123;</span><br><span class="line">  display: flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    不过需要注意一点，就是设为 Flex 布局以后，子元素的float、clear和vertical-align属性将失效。也就是说浮动布局和弹性布局不可共存，二者必居其一。</p><p>​    其实flex布局原理很简单，采用 Flex 布局的元素，称为 Flex 容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称”项目”。</p><p>​    容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。</p><p>​    项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。</p><p><img src="https://v3u.cn/v3u/Public/js/editor/attached/image/20190903/20190903092949_52083.png" alt="img"> </p><p>​    弹性布局的容器可以设置下面这些属性： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">flex-direction</span><br><span class="line">flex-direction属性决定主轴的方向（即项目的排列方向）。</span><br><span class="line">.box &#123;</span><br><span class="line">  flex-direction: row | row-reverse | column | column-reverse;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">flex-wrap</span><br><span class="line">默认情况下，项目都排在一条线（又称&quot;轴线&quot;）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。</span><br><span class="line">.box&#123;</span><br><span class="line">  flex-wrap: nowrap | wrap | wrap-reverse;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">flex-flow</span><br><span class="line">flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。</span><br><span class="line">.box &#123;</span><br><span class="line">  flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">justify-content</span><br><span class="line">justify-content属性定义了项目在主轴上的对齐方式。</span><br><span class="line">.box &#123;</span><br><span class="line">  justify-content: flex-start | flex-end | center | space-between | space-around;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">align-items</span><br><span class="line">align-items属性定义项目在交叉轴上如何对齐。</span><br><span class="line">.box &#123;</span><br><span class="line">  align-items: flex-start | flex-end | center | baseline | stretch;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">align-content</span><br><span class="line">align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。</span><br><span class="line">.box &#123;</span><br><span class="line">  align-content: flex-start | flex-end | center | space-between | space-around | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    说了这么多，都是理论，我们来用弹性布局实战一下，比如我们要模仿瑞辛咖啡小程序中的，首行单列，换行双列，并且自适应整个手机页面的布局 </p><p><img src="https://v3u.cn/v3u/Public/js/editor/attached/image/20190903/20190903093515_29325.png" alt="img"> </p><p>​    页面部分: </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">        &lt;div class=&quot;container1&quot;&gt;</span><br><span class="line"> </span><br><span class="line">            &lt;div class=&quot;item11&quot;&gt;</span><br><span class="line">            1</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">            </span><br><span class="line">           &lt;div class=&quot;item12&quot;&gt;</span><br><span class="line">            </span><br><span class="line">              &lt;div class=&quot;item1&quot;&gt;</span><br><span class="line">                  3</span><br><span class="line">                  &lt;/div&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                  &lt;div class=&quot;item1&quot;&gt;</span><br><span class="line">                      3</span><br><span class="line">                      &lt;/div&gt;</span><br><span class="line">            </span><br><span class="line">          &lt;/div&gt;</span><br><span class="line">            </span><br><span class="line">            &lt;div class=&quot;item12&quot;&gt;</span><br><span class="line">              </span><br><span class="line">                &lt;div class=&quot;item1&quot;&gt;</span><br><span class="line">                    3</span><br><span class="line">                    &lt;/div&gt;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">                    &lt;div class=&quot;item1&quot;&gt;</span><br><span class="line">                        3</span><br><span class="line">                        &lt;/div&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">            </span><br><span class="line">         </span><br><span class="line">            </span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      </span><br><span class="line"></span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;/template&gt;</span><br><span class="line">    css部分:</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">.container1&#123;</span><br><span class="line">  height: 100%;</span><br><span class="line">  width:100%;</span><br><span class="line">  background-color:beige;</span><br><span class="line">  display:flex;</span><br><span class="line">  flex-flow:column;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.item11&#123;</span><br><span class="line">  height:300rpx;</span><br><span class="line">  background-color:cyan;</span><br><span class="line">  border: 1px solid #fff</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.item12&#123;</span><br><span class="line">  height:300rpx;</span><br><span class="line">  background-color:cyan;</span><br><span class="line">  border: 1px solid #fff;</span><br><span class="line">  display:flex;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">.item1&#123;</span><br><span class="line">  height:300rpx;</span><br><span class="line">  width: 50%;</span><br><span class="line">  background-color:cyan;</span><br><span class="line">  border: 1px solid #fff</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    轻松搞定，代码量比浮动布局少了很多，简直完美。 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;​    我们知道，写习惯了前端的人，一般切图后布局页面的话，上手最习惯的是基于盒子模型的浮动布局，依赖 display 属性 + position属性 + float属性，但是浮动布局有一些致命的小问题，比如垂直居中比较费劲，比如著名的&lt;a href=&quot;https://v
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Thrift重构HTTP接口</title>
    <link href="https://zxyyee.cn/post/Thrift%E9%87%8D%E6%9E%84HTTP%E6%8E%A5%E5%8F%A3.html"/>
    <id>https://zxyyee.cn/post/Thrift重构HTTP接口.html</id>
    <published>2019-08-04T17:51:49.000Z</published>
    <updated>2019-09-18T07:36:27.615Z</updated>
    
    <content type="html"><![CDATA[<p>​    目前市面上类似Django的drf框架基于json的http接口解决方案大行其道，人们也热衷于在接口不多、系统与系统交互较少的情况下使用它，http接口的优点就是简单、直接、开发方便，门槛低，利用现成的http协议进行传输。</p><p>​    但是事情往往有两面，如果是一个大型的网站，内部子系统较多、接口非常多的情况下，RPC框架的好处就显示出来了，首先就是长链接，不必每次通信都要像http 一样去3次握手4次挥手，减少了网络开销；其次就是RPC框架一般都有注册中心，有丰富的监控管理；发布、下线接口、动态扩展等，对调用方来说是无感知、统一化的操作。第三个来说就是安全性。最后就是最近流行的服务化架构、服务化治理，RPC框架是一个强力的支撑。</p><p>​    论复杂度，RPC框架肯定是高于简单的HTTP接口的。但毋庸置疑，HTTP接口由于受限于HTTP协议，需要带HTTP请求头，导致传输起来效率或者说安全性不如RPC，目前市面上流行的rpc框架有dubbo/hessian Thrift，阿里开源的dubbo固然还不错，但是本人更倾向于facebook开源的Thrift框架，这款框架在github上好评如潮，这一次我们使用的就是基于Thrift的thriftpy2框架。</p><p>​    Thrift是一种接口描述语言和二进制通讯协议，它被用来定义和创建跨语言的服务，这是维基百科的描述。简单来说就是你可以按照Thrift定义语法编写.thrift,然后用Thrift命令行生成各种语言的代码，比如OC、Java、C++、JS，调用这些代码就可以完成客户端与服务器的通信了，不需要自己去写网络请求、数据解析等接口。</p><p>​    其实在本人的实际教学工作中主要考虑到这两个优点：</p><p>​    RPC。通过简单定义Thrift描述语言文件，使用Thrift -gen命令可以生成多种语言的代码，这些代码包含了网络通信,数据编解码的功能。这就免去了前后台编写这部分繁琐的代码，同时也统一了前后台的实现逻辑。</p><p>​    Thrift的二进制数据的编码比json更加紧凑、减少了无用的数据的传输。</p><p>​    </p><p>​    安装:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install thriftpy2</span><br></pre></td></tr></table></figure><p>​    首先定义 thrift 通讯文件，无论是server端还是clinet端都是基于这个文件进行通信 pingpong.thrift </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">service PingPong &#123;</span><br><span class="line">    string ping(),</span><br><span class="line">    string check_login(</span><br><span class="line">        1: string username,</span><br><span class="line">        2: string password</span><br><span class="line">    ),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    可以看到我们定义了两个方法，一个有参一个无参，第一个方法用来检测接口是否通信成功，也就是传统的ping命令，第二个方法顾名思义，用户登录</p><p>​    然后建立一个thrift_server.py 建立服务端的代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import thriftpy2</span><br><span class="line">pingpong_thrift = thriftpy2.load(&quot;pingpong.thrift&quot;, module_name=&quot;pingpong_thrift&quot;)</span><br><span class="line"></span><br><span class="line">from thriftpy2.rpc import make_server</span><br><span class="line"></span><br><span class="line">class Dispatcher(object):</span><br><span class="line">    </span><br><span class="line">    def ping(self):</span><br><span class="line">        return &quot;pong&quot;</span><br><span class="line"></span><br><span class="line">    def check_login(self,username,password):</span><br><span class="line">        print(username,password)</span><br><span class="line">        return &apos;123&apos;</span><br><span class="line"></span><br><span class="line">server = make_server(pingpong_thrift.PingPong, Dispatcher(), &apos;127.0.0.1&apos;, 6000)</span><br><span class="line">server.serve()</span><br></pre></td></tr></table></figure><p>​    服务端首先读取通信文件，然后建立起一个服务，监听6000端口，等待客户端请求，实际上服务端的方法也是主要业务逻辑编写的地方。</p><p>​    随后建立一个thrift_client.py文件，编写客户端代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import thriftpy2</span><br><span class="line">pingpong_thrift = thriftpy2.load(&quot;pingpong.thrift&quot;, module_name=&quot;pingpong_thrift&quot;)</span><br><span class="line"></span><br><span class="line">from thriftpy2.rpc import make_client</span><br><span class="line"></span><br><span class="line">client = make_client(pingpong_thrift.PingPong, &apos;127.0.0.1&apos;, 6000)</span><br><span class="line"></span><br><span class="line">print(client.ping())</span><br><span class="line"></span><br><span class="line">print(client.check_login(&apos;admin&apos;,&apos;123456&apos;))</span><br></pre></td></tr></table></figure><p>​    我们看到客户端同样读取通信文件，严格按照通信文件的方法调用方式进行传参调用，获取返回值</p><p>​    运行服务器端的服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 thrift_server.py</span><br></pre></td></tr></table></figure><p>​    可以看到服务端和客户端就可以通信了</p><p>​    可以说非常简单，这里着重提到的一点是Thrift的数据编解码，我们知道传统http接口通常以json为数据介质，json中一个对象类似于这样的：{“key”:”content”},但实际上这个对象只有“content”才是我们真正想要的数据，而“key”这个字符串并不是我们实际需要的，只是为了做一个标记，方便我们查找“content”。而Thrift则可以省去“key”这个多余的字符串。</p><p>​    定义thrift的结构里的属性名称实际上在thrift数据二进制编解码是被忽略的（thrift的json编解码未验证），这个名称的作用只是作为生成的OC代码类的属性名称。这也解释了为什么Thrift的二进制编码会比平时使用的json更省流量。同时也说明了只要我们在.thrift文件中定义struct的时候保证struct的属性的顺序不变，即使通信双方使用了各自使用不同的属性名称也不会有问题。</p><p>​    随着请求并发量的提高，简单的HTTP肯定达不到预期的效果，Thrift或许才是你寻找的答案。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;​    目前市面上类似Django的drf框架基于json的http接口解决方案大行其道，人们也热衷于在接口不多、系统与系统交互较少的情况下使用它，http接口的优点就是简单、直接、开发方便，门槛低，利用现成的http协议进行传输。&lt;/p&gt;
&lt;p&gt;​    但是事情往往有
      
    
    </summary>
    
      <category term="web" scheme="https://zxyyee.cn/categories/web/"/>
    
    
      <category term="web" scheme="https://zxyyee.cn/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>使用基于mpvue的框架开发微信小程序（搭建环境）</title>
    <link href="https://zxyyee.cn/post/%E4%BD%BF%E7%94%A8%E5%9F%BA%E4%BA%8Empvue%E7%9A%84%E6%A1%86%E6%9E%B6%E5%BC%80%E5%8F%91%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%EF%BC%88%E6%90%AD%E5%BB%BA%E7%8E%AF%E5%A2%83%EF%BC%89.html"/>
    <id>https://zxyyee.cn/post/使用基于mpvue的框架开发微信小程序（搭建环境）.html</id>
    <published>2019-07-30T12:53:06.000Z</published>
    <updated>2019-09-05T12:58:36.935Z</updated>
    
    <content type="html"><![CDATA[<p>​    美团很早就开源了mpvue这个项目，如此看来，美团可不仅仅是一家团购网站，真正的技术驱动型企业，使得我们多了一种用来开发微信小程序的框架选项。由于mpvue框架是完全基于Vue框架的（重写了其runtime和compiler），因此在用法上面是高度和Vue一致的（某些功能由于受限于小程序环境本身的原因而不能使用，但是瑕不掩瑜），这给使用过Vue开发Web应用的前端开发者提供了极低的门槛来开发小程序。</p><p>​    搭建所需的软件环境，首先mpvue是基于vue.js，同时也需要vue-cli脚手架，注意一点：你的node环境版本必须大于9.0，否则会出现和新版mpvue不兼容的情况，首先去微信公众号平台注册开发者账号： <a href="https://mp.weixin.qq.com/" target="_blank" rel="noopener">https://mp.weixin.qq.com</a>  记得验证一下开发者身份，另外获取appid，并且点击生成appsecret秘钥，一般审核速度很快，大概一天就会通过。附上微信小程序开发文档：<a href="https://developers.weixin.qq.com/miniprogram/dev/framework/" target="_blank" rel="noopener">https://developers.weixin.qq.com/miniprogram/dev/framework/</a></p><p><img src="https://v3u.cn/v3u/Public/js/editor/attached/image/20190826/20190826020248_68338.png" alt="img"> </p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">npm cache clean --force</span><br><span class="line"></span><br><span class="line">npm set registry https://registry.npmjs.org/</span><br><span class="line"></span><br><span class="line">npm install npm -g</span><br><span class="line"></span><br><span class="line">npm install -g vue-cli</span><br><span class="line"></span><br><span class="line">npm cache clean --force</span><br></pre></td></tr></table></figure><pre><code>安装好之后，查看node版本是否大于9.0 node -v</code></pre><p>​    之后，运行命令，创建一个mpvue的工程</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue init mpvue/mpvue-quickstart mpvue</span><br></pre></td></tr></table></figure><p><img src="https://v3u.cn/v3u/Public/js/editor/attached/image/20190826/20190826015419_44189.png" alt="img"> </p><p>​    图上的appid就是注册时获取到的</p><p>​    随后进入到项目目录中：cd mpvue</p><p>​    输入命令安装依赖</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure><p>安装成功后，在项目目录下输入npm run dev 启动项目 </p><p><img src="https://v3u.cn/v3u/Public/js/editor/attached/image/20190826/20190826020212_12687.png" alt="img"> </p><p>mpvue的项目结构是这样的： </p><p><img src="https://v3u.cn/v3u/Public/js/editor/attached/image/20190826/20190826020404_34999.png" alt="img"> </p><p>​    可以看到，和传统的vue项目没有任何差别，简直太友好了</p><p>​    此时，可以去下载一个微信小程序开发者工具：<a href="https://developers.weixin.qq.com/miniprogram/dev/devtools/download.html" target="_blank" rel="noopener">https://developers.weixin.qq.com/miniprogram/dev/devtools/download.html</a></p><p>​    选择适合自己系统的版本下载，这里我下载mac版，缺点是体积有点略大，安装后要500多m，希望腾讯以后可以压缩一下，轻量级开发工具应该小巧轻便。</p><p>​    打开微信小程序开发工具，点击➕新建项目</p><p><img src="https://v3u.cn/v3u/Public/js/editor/attached/image/20190826/20190826020803_40950.png" alt="img"> </p><p>​    选择导入项目，输入项目目录以及appid </p><p><img src="https://v3u.cn/v3u/Public/js/editor/attached/image/20190826/20190826020901_60912.png" alt="img"> </p><p>​    最后打开导入的项目，这时候需要耐心等待一小会，不要着急</p><p>​    成功打开后，就可以看到界面了</p><p><img src="https://v3u.cn/v3u/Public/js/editor/attached/image/20190826/20190826021045_26005.png" alt="img"> </p><p>​    此时只要修改对应的vue组件，小程序就会实时进行更改，不过需要注意一点，新建组件的时候，需要手动重启mpvue项目:npm run dev</p><p>​    是不是很简单呢，如果你是一位精通vue的开发者，那么开发微信小程序对于你来说也就是 a piece of cake</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;​    美团很早就开源了mpvue这个项目，如此看来，美团可不仅仅是一家团购网站，真正的技术驱动型企业，使得我们多了一种用来开发微信小程序的框架选项。由于mpvue框架是完全基于Vue框架的（重写了其runtime和compiler），因此在用法上面是高度和Vue一致的（
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>浏览器同源策略与ajax跨域方法汇总</title>
    <link href="https://zxyyee.cn/post/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5%E4%B8%8Eajax%E8%B7%A8%E5%9F%9F%E6%96%B9%E6%B3%95%E6%B1%87%E6%80%BB.html"/>
    <id>https://zxyyee.cn/post/浏览器同源策略与ajax跨域方法汇总.html</id>
    <published>2019-07-25T14:25:08.000Z</published>
    <updated>2019-09-09T06:28:11.338Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文先简要介绍前端开发中的浏览器同源政策；然后在跨域问题中，具体介绍跨域ajax请求的应用场景与实现方案。</p></blockquote><h2 id="什么是同源策略"><a href="#什么是同源策略" class="headerlink" title="什么是同源策略"></a>什么是同源策略</h2><p>如果你进行过前端开发，肯定或多或少会听说过、接触过所谓的同源策略。那么什么是同源策略呢？</p><p>要了解同源策略，首先得理解“源”。在这个语境下，源(origin)其实就是指的URL。所以，我们需要先理解URL的组成。看看这个URL：<br><a href="https://www.jianshu.com/p/bc7b8d542dcd" target="_blank" rel="noopener">http://www.jianshu.com/p/bc7b8d542dcd</a></p><p>我们可以将它拆解为下面几个部分协议、域名和路径：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http       :// www.jianshu.com    /p/bc7b8d542dcd</span><br><span class="line">$&#123;protocol&#125;:// $&#123;hostname&#125;         $&#123;pathname&#125;</span><br></pre></td></tr></table></figure><p>而对于一个更为完整的URL<code>http://www.jianshu.com:80/p/bc7b8d542dcd#sample?query=text</code></p><table><thead><tr><th>protocol</th><th>host</th><th>port</th><th>pathname</th><th>hash</th><th>query string</th></tr></thead><tbody><tr><td>http</td><td><a href="https://www.jianshu.com/" target="_blank" rel="noopener">www.jianshu.com</a></td><td>80</td><td>/p/bc7b8d542dcd</td><td>sample</td><td>query=text</td></tr><tr><td><code>location.protocol</code></td><td><code>location.host</code></td><td><code>location.port</code></td><td><code>location.pathname</code></td><td><code>location.hash</code></td><td><code>location.search</code></td></tr></tbody></table><p>而同源就是指URL中<code>protocol</code>协议、<code>host</code>域名、<code>port</code>端口这三个部分相同。</p><p>下表是各个URL相对于<a href="https://www.jianshu.com/p/bc7b8d542dcd" target="_blank" rel="noopener">http://www.jianshu.com/p/bc7b8d542dcd</a>的同源检测结果</p><table><thead><tr><th>URL</th><th>是否同源</th><th>非同源原因</th></tr></thead><tbody><tr><td><code>http://www.jianshu.com/p/0b2acb50f321</code></td><td>是</td><td></td></tr><tr><td><code>https://www.jianshu.com/p/0b2acb50f321</code></td><td>否</td><td>不同协议</td></tr><tr><td><code>http://www.jianshu.com:8080/p/0b2acb50f321</code></td><td>否</td><td>不同端口</td></tr><tr><td><code>http://www.jianshu2.com/p/0b2acb50f321</code></td><td>否</td><td>不同域名</td></tr></tbody></table><p>因此，简单来说，同源策略就是浏览器出于网站安全性的考虑，限制不同源之间的资源相互访问的一种政策。以下操作具有同源策略的限制：</p><ul><li>AJAX 请求不能发送。</li><li>无法获取DOM元素并进行操作。</li><li>无法读取Cookie、LocalStorage 和 IndexDB 。</li></ul><p>而本文就会针对<strong>跨域AJAX</strong>场景及其各种常见解决方案进行相关介绍。</p><p>值得一提的是，有些请求是不受到跨域限制。例如：WebSocket，script、img、iframe、video、audio标签的<code>src</code>属性等。</p><h2 id="为什么实际开发中会有跨域ajax请求"><a href="#为什么实际开发中会有跨域ajax请求" class="headerlink" title="为什么实际开发中会有跨域ajax请求"></a>为什么实际开发中会有跨域ajax请求</h2><p>根据上文的内容我们可以知道，由于浏览器同源政策的影响，跨域的ajax请求是不被允许。那么在实际的开发、应用中，是否有跨域ajax的场景呢？</p><p>答案是肯定的。</p><p>那么有哪些场景会有跨域ajax的需求呢？</p><ol><li>当你调用一个现有的API或公开API：想象一下，你接到了一个新需求，需要在当前开发的新闻详细页<code>http://www.yournews.com/p/123</code>展示该新闻的相关推荐。令人欣慰的是，推荐的接口已经在你们公司的其他产品线里实现了，你只需要给该接口一个<code>query</code>即可：<code>http://www.mynews.com/recommend?query=123</code>。然而问题来了——你发起了一个跨域请求。</li><li>前后端分离的开发模式下，在本地进行接口联调时：也许在你的项目里，你想尝试前后端分离的开发模式。你在本地开发时，mock了一些假数据来帮助自己本地开发。而有一天，你希望在本地和后端同学进行联调。此时，后端rd的接口地址和你发生了跨域问题。这阻止了你们的联调，你只能继续使用你mock的假数据。</li></ol><p>上面只是列举了存在跨域的两个最为常见的场景，这足以说明跨域请求在实际开发中确实经常出现。</p><h2 id="跨域的一些方案"><a href="#跨域的一些方案" class="headerlink" title="跨域的一些方案"></a>跨域的一些方案</h2><p>了解了上面的内容后，下面就来介绍一下在实践中常用的三种ajax跨域方案。这部分的实例代码可以在这里看到：<a href="https://link.jianshu.com/?t=https://github.com/alienzhou/cross-domain-demo" target="_blank" rel="noopener">cross-domain-demo</a></p><p>假设这样一个跨域场景：目前有两个项目</p><ul><li><strong>myweb</strong>，这个就是我们目前开发的项目，是一个独立的站点。</li><li><strong>thirdparty</strong>，表示我们需要调用到的第三方（third-party）后端服务，myweb项目就是需要调用它的接口。</li></ul><p>为了简化不必要的代码编写过程，示例使用<code>express-generator</code>来快速生成myweb与thirdparty这两个应用，其中thirdparty我们只需要用到后端接口部分。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install express-generator -g</span><br><span class="line">express --view=pug myweb</span><br><span class="line">express --view=pug thirdparty</span><br></pre></td></tr></table></figure><p>在myweb中，index页面 <code>http://127.0.0.1:8085</code>需要跨域访问server中的<code>http://127.0.0.1:3000/info/normal</code>这个接口的信息。前端操作是：当点击<code>button</code>时就会去获取info，并alert出来。<br>跨域访问的接口<code>http://127.0.0.1:3000/info/normal</code>代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const express = require(&apos;express&apos;);</span><br><span class="line">const router = express.Router();</span><br><span class="line"></span><br><span class="line">const data = &#123;</span><br><span class="line">    name: &apos;alienzhou&apos;,</span><br><span class="line">    desc: &apos;a developer&apos;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">router.get(&apos;/normal&apos;, (req, res, next) =&gt; &#123;</span><br><span class="line">    res.json(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>然后是<code>http://127.0.0.1:8085</code>index页面的部分的javascript</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// http://127.0.0.1:8085  -- index.js</span><br><span class="line">document.getElementById(&apos;btn-1&apos;).addEventListener(&apos;click&apos;, function() &#123;</span><br><span class="line">    var xhr = new XMLHttpRequest();</span><br><span class="line">    xhr.onreadystatechange = function() &#123;</span><br><span class="line">        if (xhr.readyState === 4 &amp;&amp; xhr.status === 200) &#123;</span><br><span class="line">            alert(xhr.responseText);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    xhr.open(&apos;get&apos;, &apos;http://127.0.0.1:3000/info/normal&apos;);</span><br><span class="line">    xhr.send(null);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>点击<code>btn-1</code>，在控制台中就会出现如下错误，这个跨域ajax请求受到了同源策略的限制。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[Error] Origin http://127.0.0.1:8085 is not allowed by Access-Control-Allow-Origin.</span><br><span class="line">[Error] Failed to load resource: Origin http://127.0.0.1:8085 is not allowed by Access-Control-Allow-Origin. (normal, line 0)</span><br><span class="line">[Error] XMLHttpRequest cannot load http://127.0.0.1:3000/info/normal due to access control checks.</span><br></pre></td></tr></table></figure><p>下面来讲具体的三种解决方案：</p><h3 id="使用代理（proxy）"><a href="#使用代理（proxy）" class="headerlink" title="使用代理（proxy）"></a>使用代理（proxy）</h3><p>这种方法本质上仍然遵循了同源政策，只是换了一个请求的思路，将请求移至了后端。</p><p>我们知道，同源政策是浏览器层面的限制。那么，如果我们不在前端跨域，而将“跨域”的任务交给后端服务，是否就规避了同源政策呢？是的。</p><p>这就是“代理”。这个代理可以将我们的请求转发，而后端并不会有所谓的同源政策限制。这个“代理”也可以理解为一个同域的后端服务。</p><p>由于我们的myweb是一个完整的web项目（包括前端部分和后端服务部分），因此，我们可以在myweb项目的后端添加一个<code>proxy</code>接口，专门处理跨域ajax请求的转发。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const express = require(&apos;express&apos;);</span><br><span class="line">const router = express.Router();</span><br><span class="line">const request = require(&apos;request&apos;);</span><br><span class="line"></span><br><span class="line">router.get(&apos;*&apos;, (req, res, next) =&gt; &#123;</span><br><span class="line">    let path = req.path.replace(/^\/proxy/, &apos;&apos;);</span><br><span class="line">    request.get(`http://127.0.0.1:3000$&#123;path&#125;`, (err, response) =&gt; &#123;</span><br><span class="line">        res.json(JSON.parse(response.body));</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">module.exports = router;</span><br></pre></td></tr></table></figure><p>这样，我们在前端访问<code>/proxy/info/normal</code>后，就会自动转发到<code>http://127.0.0.1:3000/proxy/info/normal</code>。</p><p>前端ajax部分如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">document.getElementById(&apos;btn-1&apos;).addEventListener(&apos;click&apos;, function() &#123;</span><br><span class="line">    var xhr = new XMLHttpRequest();</span><br><span class="line">    xhr.onreadystatechange = function() &#123;</span><br><span class="line">        if (xhr.readyState === 4 &amp;&amp; xhr.status === 200) &#123;</span><br><span class="line">            alert(xhr.responseText);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    xhr.open(&apos;get&apos;, &apos;/proxy/info/normal&apos;);</span><br><span class="line">    xhr.send(null);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>该方法的优点很明显：不需要第三方服务<code>http://127.0.0.1:3000/info/normal</code>进行任何改造。</p><p>当然，该方法也有一些缺点：</p><ul><li>首先，需要你有一个自己的后端服务能够接收并转发请求。如果你进行本地的纯静态页面开发，则需要一些浏览器插件或自动化工具中集成的本地服务器来实现。</li><li>此外，如果请求包含一些特殊的请求头（例如cookie等等），需要在转发时特殊处理。</li></ul><p>下面两种方法则需要第三方服务端或多或少进行配合改造。</p><h3 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h3><p>同源策略往往过于严格了，为了解决浏览器的这个问题，w3c提出了CORS（Cross-Origin Resource Sharing）标准。CORS通过相应的请求头与响应头来实现跨域资源访问。</p><p>如果我们打开控制台，可以在请求头中发现一个叫<code>origin</code>的头信息，它表明了请求的来源。这是浏览器自动添加的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Referer: http://127.0.0.1:8085/</span><br><span class="line">Origin: http://127.0.0.1:8085   &lt;============   origin</span><br><span class="line">Accept: */*</span><br><span class="line">Cache-Control: no-cache</span><br><span class="line">User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_6) AppleWebKit/603.3.8 (KHTML, like Gecko) Version/10.1.2 Safari/603.3.8</span><br><span class="line">Pragma: no-cache</span><br></pre></td></tr></table></figure><p>与之对应的，服务器端的响应头中一个头信息为<code>Access-Control-Allow-Origin</code>，表明接受的跨域请求来源。显而易见，这两个信息如果一致，则这个请求就会被接受。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">router.get(&apos;/cors&apos;, (req, res, next) =&gt; &#123;</span><br><span class="line">    res.setHeader(&apos;Access-Control-Allow-Origin&apos;, &apos;http://127.0.0.1:8085&apos;);</span><br><span class="line">    res.json(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>如果将<code>Access-Control-Allow-Origin</code>的值设置为<code>*</code>，则会接受所有域的请求。这时的客户端不需要任何配置即可进行跨域访问。</p><p>然而，还有一个问题，CORS默认是不会发送cookie，但是如果我希望这次的请求也能够带上对方服务所需的cookie怎么办？那就需要再进行一定的改造。</p><p>与<code>Access-Control-Allow-Origin</code>相配套的，还有一个叫<code>Access-Control-Allow-Credentials</code>的响应头，如果设置为<code>true</code>则表明服务器允许该请求内包含cookie信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">router.get(&apos;/cors&apos;, (req, res, next) =&gt; &#123;</span><br><span class="line">    res.setHeader(&apos;Access-Control-Allow-Origin&apos;, &apos;http://127.0.0.1:8085&apos;);</span><br><span class="line">    res.setHeader(&apos;Access-Control-Allow-Credentials&apos;, true);</span><br><span class="line">    res.json(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>同时，在客户端，还需要在ajax请求中设置<code>withCredentials</code>属性为<code>true</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">document.getElementById(&apos;btn-1&apos;).addEventListener(&apos;click&apos;, function() &#123;</span><br><span class="line">    var xhr = new XMLHttpRequest();</span><br><span class="line">    xhr.withCredentials = true;  // 设置withCredentials以便发送cookie</span><br><span class="line">    xhr.onreadystatechange = function() &#123;</span><br><span class="line">        if (xhr.readyState === 4 &amp;&amp; xhr.status === 200) &#123;</span><br><span class="line">            alert(xhr.responseText);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    xhr.open(&apos;get&apos;, &apos;http://127.0.0.1:3000/info/cors&apos;);  // 跨域请求</span><br><span class="line">    xhr.send(null);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>可以看到，CORS方法有如下优点：</p><ul><li>简单，几乎不需要什么开发量，只需要简单配置相应的请求与响应头信息即可。</li><li>支持各种类型的请求（<code>get</code>, <code>post</code>, <code>put</code>等等）。</li></ul><p>但缺点是：</p><ul><li>需要对跨域的服务接口进行一定的改造。如果该服务因为某些原因无法改造，则无法实现。但这种改造还是相对较小的。</li><li>不兼容一些“古董”浏览器。</li></ul><h3 id="jsonp"><a href="#jsonp" class="headerlink" title="jsonp"></a>jsonp</h3><p>jsonp是跨域领域中历史非常传统的一种方法。如果你还记得第一部分中我们提到过的内容，一些跨域请求是不会受到同源政策的限制的。其中，<code>script</code>标签就是一个。</p><p>在<code>script</code>标签中我们可以引用其他服务上的脚本，最常见的场景就是CDN。因此，有人想到，当有跨域请求到来时，如果我们可以把客户端需要的数据写到javascript脚本文件中并返回给客户端，那么客户端就可以拿到这些数据并使用了。具体是怎样一个流程呢？</p><ol><li>首先，在myweb端，我们可以预先定义一个处理函数，叫它<code>callback</code>；</li><li>然后，在myweb端，我们动态创建一个script标签，并将该标签的<code>src</code>属性指向跨域的接口，并将<code>callback</code>函数名作为请求的参数；</li><li>跨域的thirdparty端接受到该请求后，返回一个javascript脚本文件，用<code>callback</code>函数包裹住数据；</li><li>这时候，前端收到响应数据会自动执行该脚本，这样便会自动执行预先定义的<code>callback</code>函数。</li></ol><p>将上面这个方法具体成下面的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// myweb 部分</span><br><span class="line">// 1. 创建回调函数callback</span><br><span class="line">function myCallback(res) &#123;</span><br><span class="line">    alert(JSON.stringify(res, null , 2));</span><br><span class="line">&#125;</span><br><span class="line">document.getElementById(&apos;btn-4&apos;).addEventListener(&apos;click&apos;, function() &#123;</span><br><span class="line">    // 2. 动态创建script标签，并设置src属性，注意参数cb=myCallback</span><br><span class="line">    var script = document.createElement(&apos;script&apos;);</span><br><span class="line">    script.src = &apos;http://127.0.0.1:3000/info/jsonp?cb=myCallback&apos;;</span><br><span class="line">    document.getElementsByTagName(&apos;head&apos;)[0].appendChild(script);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// thirdparty</span><br><span class="line">router.get(&apos;/jsonp&apos;, (req, res, next) =&gt; &#123;</span><br><span class="line">    var str = JSON.stringify(data);</span><br><span class="line">    // 3. 创建script脚本内容，用`callback`函数包裹住数据</span><br><span class="line">    // 形式：callback(data)</span><br><span class="line">    var script = `$&#123;req.query.cb&#125;($&#123;str&#125;)`;</span><br><span class="line">    res.send(script);</span><br><span class="line">&#125;);</span><br><span class="line">// 4. 前端收到响应数据会自动执行该脚本</span><br></pre></td></tr></table></figure><p>当然，如果你是用类似jquery这样的库，其中的<code>$.ajax</code>本身是封装了JSONP方式的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">    url: &apos;http://127.0.0.1:3000/info/jsonp?cb=myCallback&apos;,</span><br><span class="line">    dataType: &apos;jsonp&apos;, // 注意，此处dataType的值表示请求使用JSONP</span><br><span class="line">    jsonp: &apos;cb&apos;, // 请求query中callback函数的键名</span><br><span class="line">&#125;).done(function (res) &#123;</span><br><span class="line">    alert(JSON.stringify(res, null , 2));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>JSONP作为一个久远的方法，其最大的优点就是兼容性非常好。</p><p>但是其缺点也很明显，由于是通过<code>script</code>标签发起的请求，因此只支持<code>get</code>请求。同时可以看到，较之CORS，其前后端改造开发量要稍高一些。如果跨域服务端不支持改造，那么也无法使用该方法。</p><hr><p>上面三个方案的实例代码可以在这里（<a href="https://link.jianshu.com/?t=https://github.com/alienzhou/cross-domain-demo" target="_blank" rel="noopener">cross-domain-demo</a>）clone到本地并运行。<code>git clone git@github.com:alienzhou/cross-domain-demo.git</code></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>同源策略作为浏览器的安全策略之一，在保证请求的安全性之外，也对我们的一些合理与期望的请求进行了控制。幸好，在面对跨域ajax请求时，我们还有一些方法可以应对它，包括使用代理、CORS和JSONP。在不同场景下合理运用各种方法，可以帮助我们有效解决ajax跨域问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文先简要介绍前端开发中的浏览器同源政策；然后在跨域问题中，具体介绍跨域ajax请求的应用场景与实现方案。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;什么是同源策略&quot;&gt;&lt;a href=&quot;#什么是同源策略&quot; class=&quot;headerlin
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>简单了解一下Python的web设计模式</title>
    <link href="https://zxyyee.cn/post/%E7%AE%80%E5%8D%95%E4%BA%86%E8%A7%A3%E4%B8%80%E4%B8%8BPython%E7%9A%84web%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html"/>
    <id>https://zxyyee.cn/post/简单了解一下Python的web设计模式.html</id>
    <published>2019-07-22T16:32:47.000Z</published>
    <updated>2019-09-18T07:41:28.133Z</updated>
    
    <content type="html"><![CDATA[<p>#前言</p><p>​    之前一直总结了很长时间的设计模式，只不过一直都是写在笔记上，并没有整理成博客。之前在学校跟一个老师聊起来的时候，他还说过，有很多东西，他只会写在本子上，从来不会公开的，我见过一些开发了十几年的java大牛，他们也不会轻易的把自己值钱的经验随便告诉给别人，跟他们一起工作，都要相近一切办法才能把值钱的东西挖过来。实际上就是这样，分享归分享，有些东西是会垄断的，你们所谓的google，facebook开源，实际上都是他们觉得不值钱的东西，值钱的东西当然不能开源，毕竟研究起来太费劲，耗费大量人力物力。还有很多人问我问题的时候会说，自己懒得看了，直接告诉他算了。对于这种伸手党也是呵呵了。</p><p>​    那么为什么我要总结这样一篇博客呢？因为我觉得这真不是啥值钱的玩意儿，如果把这点东西还当宝贝，那这辈子眼界也就这么窄了，还有我觉得很少有人会看我的博客。</p><p>​    以上就当我扯淡了，这篇博客的题目叫python的web设计模式。为什么会叫一个这样的题目呢？首先我觉得，要给自己在工作中所做的事，下一个定义，首先我是一个python工程师，并且我在做web开发，那么一些设计模式，对于我而言是没有用的（当然实际上我也是会的）。而另一些，是我要去加强的。</p><p>​    那么我们就来讲讲，作为一个python web开发者，我们可以忽略掉哪些设计模式，可以加强哪些设计模式？ 那么在看这篇博客之前，你自然需要先了解设计模式啦，否则下面的内容你是看不懂的。</p><h1 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h1><p>​    实际上我觉得web开发用的最少的就是创建者模式，在我的印象中，GUI和一些游戏的开发可能用的会更多。作为用来建模的设计模式而言，web开发的orm层可能才会用到，毕竟web开发的核心在数据流的处理和状态的维护。</p><h3 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h3><hr><p>​    抽象工厂用来创建产品簇，这个我记得在java开发跨平台GUI的解决方案有用到，比如Text，Diagram，Rectangle这些，在window上一套，在linux上一套，这个时候就需要抽象工厂模式来创建这种产品簇，web？我没用过。</p><h3 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h3><hr><p>​    之前说道抽象工厂是在不同平台去实现统一的产品簇，而建造者模式用于实现一个xx的产品，比如有个XAF的c#开发库，写好orm和基础handler，就可以生成web和GUI两套界面，内容和操作交互基本都是一样的。web？我没用过。</p><h3 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h3><hr><p>​    orm中建立数据库链接的那一套东西，基本都是工厂方法的。getConnection，能获得不同类型的数据库链接对象，因为额工厂方法的用以就是定义一个创建产品对象的工厂接口，将实际工作推迟到子类中。在.net里面的数据库链接对象就是产生数据命令对象的工厂，每种数据库的Connection对象里(继承自己的IDbconnection)都对自己的createCommand(定义在IDbCommand里)的实现。</p><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><hr><p>​    实际上python非常好实现单例模式，只要把全局状态放在私有变量中，并提供用于访问此变量的公开函数就行了。网上还有写标准的python单例类写法，继承此类就可以使用，这么说吧，logging对象就算是一个单例，数据库连接池也是单例。这个模式还是很简单常见的。</p><h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3><hr><p>​    我只有在写单测的时候，用过此技术来从初始对象deepcopy过来，进行修改运行不同单测。</p><p>​    与直接new一个对象不同的是，原型模式的clone技术，更加说明两个对象是上下文相关的，而new出来的对象是上下文无关的。而且比如你的对象初始化要靠读取文件或者数据库，那么clone出来一个的代价要比new一个小得多。</p><p>​    据说orm底层使用了原型模式，在orm对象上做了修改之后，其实会通过原型模式做一个对象链，在保存的时候，会将前后两个对象做对比，相同的就不会修改，不相同的就生成相应的sql语句。</p><h1 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h1><h3 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h3><hr><p>​    适配器模式算是最常见的设计模式了。主要用途就是将一种对象改造成另一种对象，或者将小对象拼成大对象。这种场景更像是，现在已经有一部分稳定上线的接口了，你开发的产品，要能使用新的接口，又能让老的接口运行，就要使用适配器来兼容老接口了。</p><p>​    在ADO.NET,Microsoft NET Framework,DataAdapter用作DataSet和数据源之间的桥接器，以便检索和保存数据。DataAdopter通过映射Fill(更改DataSet中的数据以便与数据源中的数据相匹配)和update(这更改了数据源中数据以便与DataSet中的数据相匹配)来提供这一桥接器。</p><h3 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h3><hr><p>​    桥接模式，将抽象（接口或算法）与实现的方式相分离，你如果做python web开发，那么你一定知道wsgi,这个就算是桥接模式，这使得python的web服务器和python的web框架完美衔接。实际上桥接模式企图搭建一个平台。比如java虚拟机，一方面，它可以运行在windows，linux，mac等不同的平台，另一方面，在它之上又运行着不同的java程序。</p><p>​    JDBC那一套东西也算是桥接模式，Driver Manager管理的API，不同的数据库厂商去实现这些接口，另一方面Jdbc应用又都是在JDBC API的基础上开发的。这样就做到了开发者与数据库厂商的分离。</p><h3 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h3><hr><p>​    将对象组合成树型结构以表示“整体，部分”的层次结构，composite模式使得客户对单个对象和组合对象的使用具有一致性。文件系统就是组合模式，xml也算是组合模式。写js的同学在操作html的时候，就对组合模式深有体会，在python的开发上，我很少使用到组合模式，可能xml库会用到吧。</p><h3 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式"></a>装饰模式</h3><hr><p>​    装饰模式是在不必改变原类文件和原用继承的情况下，动态的扩展一个对象的功能，通过一个包装对象，也就是装饰器来包裹真实的对象。实际上python在语法层面上就支持装饰模式，也是就@，比较经典的使用，我记得是tornado中<code>@tornado.gen.coroutine</code>使用yield来写异步代码，还有就是python中对于类的一些属性方法装饰器。提到一点的是，java io就在使用装饰器模式，什么InputStream，ByteArrayInputStream，FileInputStream，实际上，如果你的代码在处理数据的时候，用yield来拆分功能点，那么使用装饰器也是很爽的。</p><h3 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h3><hr><p>​    外观模式主要提供一个整洁的一致性接口给客户端，N层构架的应用程序，就算是Facade模式了。也就是同一类产品簇提供相同的接口。这个我觉得在设计web服务的时候会用到，比如我之前的web服务都会有两层，在基础服务这一层前面再挡一层业务曾，这样对于客户端前端的调用而言，业务层暴露的接口就是统一，简单的。</p><h3 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h3><hr><p>​    它通过使用共享物件，用来经可能的减少内存使用量以及分享咨询给尽可能多的相似物体。文字处理系统中图形字符，.net的string类型，python的str，和一些不可变对象都使用了享元模式。这个在web开发中，几乎没用到过。这个在开发中几乎用不到，因为此模式，一般用于解决系统性能问题，所以经常用于底层开发，在项目中并不常用。</p><h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><hr><p>​    代理模式也是一种常见的模式，1.为其他对象提供一种代理以控制这个对象的访问，解决直接访问某些对象出现的问题。</p><p>​    代理模式的根本根本是，保护一个对象的操作，在一个对象的操作上，追加其他方法。</p><p>​    在实际生产中，我们可以看到：</p><p>​        1，远程代理，能够为一个位于不同的地址空间的对象提供一个本地的代理对象。</p><p>​        2，保护代理，用于保护对象的访问权限。</p><p>​        3，智能指针，取代简单的指针，在访问对象时，提供额外的附加操作。</p><p>​        4，copy-on-write, 延迟处理的代理。</p><p>​    我觉得单元测试中的mock对象也算是代理对象，当然你最常见到的还是代理服务器，vpn之类的。</p><h3 id="行为模式"><a href="#行为模式" class="headerlink" title="行为模式"></a>行为模式</h3><hr><p>​    创建型模式关注对象的创建，结构型模式关注类和对象之间的组织关系，而行为模式关注对象间的交互和职责分配。</p><p>​    所以我觉得结构型模式才是web开发最常用的，创建和行为模式都不是特别常用。</p><h3 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h3><hr><p>​    将行为抽象成对象的模式？记录每一步操作，可以undo，redo。我是没用过。。。</p><h3 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h3><hr><p>​    迭代器模式是一个很常用的模式，它分离了聚合对象的遍历行为，抽象出了一个迭代器负责，这样既可以做到不暴露集合内部结构，又可以让外部代码透明的访问集合内部数据。<br>    范型都用了迭代器模式，但是这个和web开发没啥关系，算是比较基础的模式吧。</p><h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><hr><p>​    发布订阅模式，这个在web开发中倒是很常用，比如你要关注此消息，那你就订阅此消息，这样把你放到一个“用户”队列中，这样消息好了，会依次通知每一个用户的。事件驱动也是玩的这招。监听某个事件。</p><h3 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h3><hr><p>​    我只知道电脑的主板，就算是中介者模式，用来解决一组对象之间的相互通信，而它们之间不需要显示的交互，但是我真没用过此模式做开发。</p><h3 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a>备忘录模式</h3><hr><p>​    这个模式是不是可以理解为每次上线服务都要做个备份？方便能够回滚？我在web开发也没用过，保存和跟踪对象的状态，以便于必要时可以把对象恢复到以前的状态。</p><h3 id="解释器模式"><a href="#解释器模式" class="headerlink" title="解释器模式"></a>解释器模式</h3><hr><p>​    这个估计只有领域型语言设计才会用到吧，解释表达式什么的，web开发估计真不会用到。</p><h3 id="模板方法"><a href="#模板方法" class="headerlink" title="模板方法"></a>模板方法</h3><hr><p>​    定义一个操作的骨架，将步骤延迟到子类中，如果你在写web框架，那么模板模式是一种在常用不过的模式了，比如你在使用tornado的时候，就会重写start()和on_finish()方法，unit库，你会去实现setup和teardown方法。</p><h3 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h3><hr><p>​    你会做一个对象链，而请求就在这个链条上传递，直到链上某个对象解决处理此请求。</p><p>​    其实异常处理就算是一种责任链，而java 中的servlet的filter也算是责任链模式，拦截就处理，不拦截就传递，你可以在web服务中插入多层责任链，验证数据和一些风控，又方便扩展。</p><h3 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h3><hr><p>​    状态模式和状态机是两个概念，状态模式实际上为了一个对象在内部状态改变时改变其行为。<br>    也就是说这些状态类实现了统一的操作接口，只不过同一个操作在不同的状态下，结果也不同。这个在游戏开发的时候，精灵类会用到，web开发我没用过，可能只有设计一站式框架才会用到把。</p><h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h3><hr><p>​    将算法推迟到子类去实现，而策略代表了一种算法簇，钩子函数就是常见的策略模式，如果这么说来，map，reduce，filter都算是策略模式了，还有sort排序传入的比较函数。</p><h3 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h3><hr><p>​    三个字，“我不会”，这个模式很难，而且基本用不到，类似于多重继承和元类设计这种东西，要么你会用，要么你别用，别你觉得你会你想试着用下，算了吧你。。。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>​    其实看到我想说的是，23种设计模式，以你的工作场景来选择学习使用总结，还要去记住真实的使用场景和例子，不要一股脑全背了。还有在python中实现方式和java中也有很大的不同。如果用python写java代码，那就是你太蠢了。还有你会发现orm中有很多值得去学习的技术。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;#前言&lt;/p&gt;
&lt;p&gt;​    之前一直总结了很长时间的设计模式，只不过一直都是写在笔记上，并没有整理成博客。之前在学校跟一个老师聊起来的时候，他还说过，有很多东西，他只会写在本子上，从来不会公开的，我见过一些开发了十几年的java大牛，他们也不会轻易的把自己值钱的经验随便
      
    
    </summary>
    
      <category term="web" scheme="https://zxyyee.cn/categories/web/"/>
    
    
      <category term="web" scheme="https://zxyyee.cn/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>docker-compose及安装</title>
    <link href="https://zxyyee.cn/post/docker-compose.html"/>
    <id>https://zxyyee.cn/post/docker-compose.html</id>
    <published>2019-07-17T17:13:24.000Z</published>
    <updated>2019-09-04T11:28:43.338Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Docker-Compose简介"><a href="#Docker-Compose简介" class="headerlink" title="Docker-Compose简介"></a>Docker-Compose简介</h3><p>Docker-Compose项目是Docker官方的开源项目，负责实现对Docker容器集群的快速编排。 Docker-Compose将所管理的容器分为三层，分别是工程（project），服务（service）以及容器（container）。Docker-Compose运行目录下的所有文件（docker-compose.yml，extends文件或环境变量文件等）组成一个工程，若无特殊指定工程名即为当前目录名。一个工程当中可包含多个服务，每个服务中定义了容器运行的镜像，参数，依赖。一个服务当中可包括多个容器实例，Docker-Compose并没有解决负载均衡的问题，因此需要借助其它工具实现服务发现及负载均衡。 Docker-Compose的工程配置文件默认为docker-compose.yml，可通过环境变量COMPOSE_FILE或-f参数自定义配置文件，其定义了多个有依赖关系的服务及每个服务运行的容器。 使用一个Dockerfile模板文件，可以让用户很方便的定义一个单独的应用容器。在工作中，经常会碰到需要多个容器相互配合来完成某项任务的情况。例如要实现一个Web项目，除了Web服务容器本身，往往还需要再加上后端的数据库服务容器，甚至还包括负载均衡容器等。 Compose允许用户通过一个单独的docker-compose.yml模板文件（YAML 格式）来定义一组相关联的应用容器为一个项目（project）。 Docker-Compose项目由Python编写，调用Docker服务提供的API来对容器进行管理。因此，只要所操作的平台支持Docker API，就可以在其上利用Compose来进行编排管理。 </p><h3 id="Docker-Compose安装"><a href="#Docker-Compose安装" class="headerlink" title="Docker-Compose安装"></a>Docker-Compose安装</h3><p>下面安装docker-compose，运行下面的脚本可以自动安装，并且授权</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo curl -L https://github.com/docker/compose/releases/download/1.21.2/docker-compose-$(uname -s)-$(uname -m) -o /usr/local/bin/docker-compose</span><br><span class="line">sudo chmod +x /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure><p>安装成功后，检查版本号</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose -v</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      docker-compose
    
    </summary>
    
      <category term="Docker" scheme="https://zxyyee.cn/categories/Docker/"/>
    
    
      <category term="Docker" scheme="https://zxyyee.cn/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>关于Tornado:真实的异步和虚假的异步</title>
    <link href="https://zxyyee.cn/post/%E5%85%B3%E4%BA%8ETornado-%E7%9C%9F%E5%AE%9E%E7%9A%84%E5%BC%82%E6%AD%A5%E5%92%8C%E8%99%9A%E5%81%87%E7%9A%84%E5%BC%82%E6%AD%A5.html"/>
    <id>https://zxyyee.cn/post/关于Tornado-真实的异步和虚假的异步.html</id>
    <published>2019-06-05T09:46:12.000Z</published>
    <updated>2019-09-18T07:40:00.698Z</updated>
    
    <content type="html"><![CDATA[<p>​    我们知道Tornado 优秀的大并发处理能力得益于它的 web server 从底层开始就自己实现了一整套基于 epoll 的单线程异步架构，其他 web 框架比如Django或者Flask的自带 server 基本是基于 wsgi 写的简单服务器，并没有自己实现底层结构。而tornado.ioloop 就是 tornado web server 最底层的实现。</p><p>​    ioloop 的实现基于 epoll ，那么什么是 epoll？ epoll 是Linux内核为处理大批量文件描述符而作了改进的 poll / select 。<br>    那么到底什么是 poll / select ？ socket 通信时的服务端，当它接受（ accept ）一个连接并建立通信后（ connection ）就进行通信，而此时我们并不知道连接的客户端有没有信息发完。 这时候我们有两种选择：<br>    一直在这里等着直到收发数据结束；<br>    每隔一会儿来看看这里有没有数据；<br>    第一种办法虽然可以解决问题，但我们要注意的是对于一个线程进程同时只能处理一个 socket 通信，其他连接只能被阻塞。 显然这种方式在单进程情况下不现实。<br>    第二种办法要比第一种好一些，多个连接可以统一在一定时间内轮流看一遍里面有没有数据要读写，看上去我们可以处理多个连接了，这个方式就是 poll / select 的解决方案。 看起来似乎解决了问题，但实际上，随着连接越来越多，轮询所花费的时间将越来越长，而服务器连接的 socket 大多不是活跃的，所以轮询所花费的大部分时间将是无用的。为了解决这个问题， epoll 被创造出来，它的概念和 poll 类似，不过每次轮询时，他只会把有数据活跃的 socket 挑出来轮询，这样在有大量连接时轮询就节省了大量时间。</p><p>​    具体说说select:select最早于1983年出现在4.2BSD中，它通过一个select()系统调用来监视多个文件描述符的数组，当select()返回后，该数组中就绪的文件描述符便会被内核修改标志位，使得进程可以获得这些文件描述符从而进行后续的读写操作。</p><p>​    </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> true &#123;</span><br><span class="line">    select(streams[])</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> streams[] &#123;</span><br><span class="line">        <span class="keyword">if</span> i has data</span><br><span class="line">        read until unavailable</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    select的优点是支持目前几乎所有的平台，缺点主要有如下2个：</p><p> 1）单个进程能够监视的文件描述符的数量存在最大限制，在Linux上一般为1024，不过可以通过修改宏定义甚至重新编译内核的方式提升这一限制。</p><p> 2）select 所维护的存储大量文件描述符的数据结构，随着文件描述符数量的增大，其复制的开销也线性增长。同时，由于网络响应时间的延迟使得大量TCP连接处于非活跃状态，但调用select()会对所有socket进行一次线性扫描，所以这也浪费了一定的开销。</p><p> poll则在1986年诞生于System V Release 3，它和select在本质上没有多大差别，但是poll没有最大文件描述符数量的限制。</p><p>​    epoll是Linux 2.6 开始出现的为处理大批量文件描述符而作了改进的poll，是Linux下多路复用IO接口select/poll的增强版本，它能显著提高程序在大量并发连接中只有少量活跃的情况下的系统CPU利用率。另一点原因就是获取事件的时候，它无须遍历整个被侦听的描述符集，只要遍历那些被内核IO事件异步唤醒而加入Ready队列的描述符集合就行了。<br> 在select/poll中，进程只有在调用一定的方法后，内核才对所有监视的文件描述符进行扫描，而epoll事先通过epoll_ctl()来注册一个文件描述符，一旦基于某个文件描述符就绪时，内核会采用类似callback的回调机制，迅速激活这个文件描述符，当进程调用epoll_wait()时便得到通知。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> true &#123;</span><br><span class="line">    active_stream[] = epoll_wait(epollfd)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> active_stream[] &#123;</span><br><span class="line">        read <span class="keyword">or</span> write till</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    两相对比，可以看出来，epoll只轮询数据活跃的socket，性能自然就比较高了。</p><p>​    而Tornado其实默认是同步阻塞机制的，为了能够实现异步，你就必须使用异步的写法才可以，这里有一个简单的demo:</p><p>​    </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span>  tornado.web <span class="keyword">import</span> RequestHandler</span><br><span class="line"><span class="keyword">import</span> tornado.ioloop</span><br><span class="line"><span class="keyword">import</span> tornado.httpclient</span><br><span class="line"><span class="keyword">import</span> tornado.web</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#异步任务</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AsyncHandler</span><span class="params">(RequestHandler)</span>:</span></span><br><span class="line"><span class="meta">    @tornado.web.asynchronous</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self)</span>:</span></span><br><span class="line">        http_client = tornado.httpclient.AsyncHTTPClient()</span><br><span class="line">        http_client.fetch(<span class="string">"http://baidu.com"</span>,</span><br><span class="line">                          callback=self.on_fetch)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">on_fetch</span><span class="params">(self, response)</span>:</span></span><br><span class="line">        print(response)</span><br><span class="line">        self.write(<span class="string">'done'</span>)</span><br><span class="line">        self.finish()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#同步任务</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SyncHandler</span><span class="params">(RequestHandler)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self)</span>:</span></span><br><span class="line">        response = requests.get(<span class="string">"http://baidu.com"</span>)</span><br><span class="line">        print(response)</span><br><span class="line">        self.write(<span class="string">'done'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_app</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> tornado.web.Application(handlers=[</span><br><span class="line">        (<span class="string">r'/async_fetch'</span>, AsyncHandler),</span><br><span class="line">        (<span class="string">r'/sync_fetch'</span>, SyncHandler),</span><br><span class="line">    ],debug=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    app = make_app()</span><br><span class="line">    app.listen(<span class="number">8000</span>)</span><br><span class="line">    tornado.ioloop.IOLoop.current().start()</span><br></pre></td></tr></table></figure><p>​    可以看到异步任务我们使用了（回调）和@tornado.web.asynchronous</p><p>​    @tornado.web.asynchronous 并不能将一个同步方法变成异步，所以修饰在同步方法上是无效的，只是告诉框架，这个方法是异步的，且只能适用于HTTP verb方法（get、post、delete、put等）。@tornado.web.asynchronous 装饰器适用于callback-style的异步方法，对于用@tornado.web.asynchronous 修饰的异步方法，需要主动self.finish()来结束该请求，普通的方法(get()等)会自动结束请求在方法返回的时候。</p><p>​    对比下效率:使用ab命令发送500个请求，每秒50个 ab -n 500 -c 50 </p><p>​    <img src="https://v3u.cn/v3u/Public/js/editor/attached/image/20190901/20190901151322_45414.png" alt="img"></p><p>​    <img src="https://v3u.cn/v3u/Public/js/editor/attached/image/20190901/20190901151335_70252.png" alt="img"></p><p>​    结果显而易见，异步效率更高，15秒完成了同步需要50秒的任务。</p><p>​    但是，要想达到异步效果，就必须使用异步写法，让io操作变成异步io，而异步写法对于后台研发的综合素质要求比较高，那么能不能用同步的写法达成异步效果呢？当然可以，就是使用<a href>celery+tornado</a></p><p>​    最后总结一下：</p><p>​    Tornado的异步原理： 单线程的torndo打开一个IO事件循环， 当碰到IO请求（新链接进来 或者 调用api获取数据），由于这些IO请求都是非阻塞的IO，都会把这些非阻塞的IO socket 扔到一个socket管理器，所以，这里单线程的CPU只要发起一个网络IO请求，就不用挂起线程等待IO结果，这个单线程的事件继续循环，接受其他请求或者IO操作，如此循环。</p><p>​    说人话：poll/select: 在一个育婴室内，护士会对育婴室内所有的婴儿挨个check一遍，如此往复。epoll:护士会使用高科技设备对婴儿进行监听，并且只会check生命体征有问题(活跃)的婴儿，如此往复。</p><p>​    另外，对于如果面对超高的并发请求(qps上万)，仅仅采用 epoll 模型是不够的，我们还必须使用多进程多线程等方式来充分利用系统资源，这就引出了<a href>nginx反向代理tornado进行负载均衡</a>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;​    我们知道Tornado 优秀的大并发处理能力得益于它的 web server 从底层开始就自己实现了一整套基于 epoll 的单线程异步架构，其他 web 框架比如Django或者Flask的自带 server 基本是基于 wsgi 写的简单服务器，并没有自己实现
      
    
    </summary>
    
      <category term="Tornado" scheme="https://zxyyee.cn/categories/Tornado/"/>
    
    
      <category term="Tornado" scheme="https://zxyyee.cn/tags/Tornado/"/>
    
  </entry>
  
  <entry>
    <title>在centos7.6上部署前后端分离项目Nginx反向代理vue.js2.6+Tornado5.1.1，使用supervisor统一管理服务</title>
    <link href="https://zxyyee.cn/post/%E5%9C%A8centos7-6%E4%B8%8A%E9%83%A8%E7%BD%B2%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E9%A1%B9%E7%9B%AENginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86vue-js2-6-Tornado5-1-1%EF%BC%8C%E4%BD%BF%E7%94%A8supervisor%E7%BB%9F%E4%B8%80%E7%AE%A1%E7%90%86%E6%9C%8D%E5%8A%A1.html"/>
    <id>https://zxyyee.cn/post/在centos7-6上部署前后端分离项目Nginx反向代理vue-js2-6-Tornado5-1-1，使用supervisor统一管理服务.html</id>
    <published>2019-05-27T15:25:01.000Z</published>
    <updated>2019-09-10T00:29:23.325Z</updated>
    
    <content type="html"><![CDATA[<p>​    这一次使用vue.js+tornado的组合来部署前后端分离的web项目，vue.js不用说了，前端当红炸子鸡，泛用性非常广，无论是单页应用，还是混合式开发app，亦或是微信小程序开发，样样得心应手，tornado最近的风头有点被新锐框架sanic抢走了，但是作为老牌的异步非阻塞框架，其内置了支持epoll/kqueue 等高效网络库，而具备了处理高并发的能力并且开发效率也不低，这一次tornado作为承载后端压力的角色。</p><p>​    首先部署前端，将测试好的vue.js2.6项目打包，值得一提的是，在生产环境并不需要node.js服务，因为利用vue.js的特性可以对前端页面进行打包，使其成为一个纯静态页包，上线后利用nginx对其代理即可，既方便又安全。在项目目录下执行npm run build命令，在执行之前，先把conifg目录下index.js中的bulid配置../dist改成./dist</p><p><img src="https://v3u.cn/v3u/Public/js/editor/attached/image/20190822/20190822125312_62859.png" alt="img"></p><p>​        执行命令后，会在项目的config目录下的dist目录生成静态页，将dist目录上传到服务器的/root目录下</p><p>​    运行 chmod 755 /root/dist 对项目文件授权</p><p>​    然后，在线上安装nginx</p><p>​    </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#设置源</span><br><span class="line">sudo rpm -Uvh http://nginx.org/packages/centos/7/noarch/RPMS/nginx-release-centos-7-0.el7.ngx.noarch.rpm</span><br><span class="line"></span><br><span class="line">#安装</span><br><span class="line">yum install -y nginx</span><br><span class="line"></span><br><span class="line">#启动服务</span><br><span class="line">systemctl start nginx.service</span><br></pre></td></tr></table></figure><p>​    服务器需要暴露80端口，此时，测试一下，看看能否显示欢迎页</p><p>​    <img src="https://v3u.cn/v3u/Public/js/editor/attached/image/20190822/20190822125636_42282.png" alt="img"></p><p>​    没有问题，这时修改一下nginx 配置文件 vim /etc/nginx/conf.d/default.conf  增加下面的配置，这里前端服务默认监听80端口</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       <span class="number">80</span>;</span><br><span class="line">    server_name  localhost;</span><br><span class="line"></span><br><span class="line">    access_log      /root/md_vue_access.log;</span><br><span class="line">    error_log       /root/md_vue_error.log;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    client_max_body_size <span class="number">75</span>M;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line"></span><br><span class="line">        root /root/dist;</span><br><span class="line">        index index.html;</span><br><span class="line">        try_files $uri $uri/ /index.html;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    error_log    /root/dist/error.log    error;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#继续修改配置</span><br><span class="line">vim /etc/nginx/nginx.conf</span><br><span class="line">将第一行改为 user root;</span><br></pre></td></tr></table></figure><p>改好后，重启nginx服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl reload nginx.service</span><br></pre></td></tr></table></figure><p>每次修改nginx配置一定要重启服务，否则修改不会生效</p><p>访问一下，看看效果</p><p><img src="https://v3u.cn/v3u/Public/js/editor/attached/image/20190822/20190822131209_18271.png" alt="img"></p><p>​    至此，前端就部署好了，是不是很简单呢？这一次我们摒弃了老美多商城丑陋而原始的模板，采用响应式设计的新模板，兼容任意大小屏幕，并且还可以打包成apk，简直棒</p><p>​    接着，我们来部署后端，首先安装python3，需要注意的是centos自带python2.7，当装软件的时候千万不要影响这个python2.7，因为系统很多东西都依赖python2，所以我们只要python2和python3共存就可以了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">yum install epel-release</span><br><span class="line"></span><br><span class="line">yum install python36</span><br><span class="line"></span><br><span class="line">wget --no-check-certificate https://bootstrap.pypa.io/get-pip.py</span><br><span class="line"></span><br><span class="line">python3 get-pip.py</span><br><span class="line"></span><br><span class="line">pip3 install pymysql</span><br><span class="line"></span><br><span class="line">pip3 install pillow</span><br><span class="line"></span><br><span class="line">pip3 install pycryptodome</span><br><span class="line"></span><br><span class="line">pip3 install tornado==5.1.1</span><br><span class="line"></span><br><span class="line">pip3 install sqlalchemy</span><br></pre></td></tr></table></figure><p>​    将tornado项目上传到/root/mytornado下，修改项目权限:chmod -R 755 /root/mytornado 然后将项目的debug模式关闭，并且修改端口号为8001，同时阿里云暴露8001端口，进行项目根目录，启动服务:python3 server.py，检查一下</p><p><img src="https://v3u.cn/v3u/Public/js/editor/attached/image/20190823/20190823013951_52792.png" alt="img"></p><p>​    没有问题，此时修改nginx配置文件，用nginx对tornado进行反向代理，新建一个配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/nginx/conf.d/tornado.conf</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">upstream tornado &#123;</span><br><span class="line">    server 127.0.0.1:8001;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen   8000;</span><br><span class="line">    root /root/mytornado;</span><br><span class="line">    index server.py index.html;</span><br><span class="line"></span><br><span class="line">    server_name server;</span><br><span class="line"></span><br><span class="line">        # 静态文件直接由Nginx处理</span><br><span class="line">    location /static/&#123;</span><br><span class="line">        alias /root/mytornado/static/;</span><br><span class="line">        expires 24h;</span><br><span class="line">    &#125;</span><br><span class="line">    location /&#123;</span><br><span class="line">        proxy_pass_header Server;</span><br><span class="line">        proxy_set_header Host $http_host;</span><br><span class="line">        proxy_redirect off;</span><br><span class="line">        proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">        # 把请求方向代理传给tornado服务器，负载均衡</span><br><span class="line">        proxy_pass http://tornado;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    </p><p>该配置的意思就是由nginx监听8000端口，并且将请求反向代理至tornado服务，这里我们只起了一个8001的服务，还可以启动更多，这就是传统意义上的负载均衡</p><p>重启一下nginx</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart nginx.service</span><br></pre></td></tr></table></figure><p>访问服务器的8000端口，阿里云也别忘了暴露一下8000</p><p><img src="https://v3u.cn/v3u/Public/js/editor/attached/image/20190823/20190823022030_20802.png" alt="img"></p><p>​    最后，每次手动在命令行启动应用是比较麻烦的，我们还需要一个能够方便的管理服务进程的工具，包括自动重启进程等，而Supervisor的作用在这里就可以体现了。我们使用它来管理这个Tornado web server相关的进程</p><p>​    安装supervisor</p><p>​    </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum install epel-release</span><br><span class="line">yum install -y supervisor</span><br></pre></td></tr></table></figure><p>​    生成配置文件</p><p>​    </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">supervisord -c /etc/supervisord.conf</span><br></pre></td></tr></table></figure><p>​    修改配置文件</p><p>​    然后修改配置文件 vim /etc/supervisord.conf   将下面几行的注释解开</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[inet_http_server]         ; inet (TCP) server disabled by default</span><br><span class="line">port=*:9001        ; (ip_address:port specifier, *:port for all iface)</span><br><span class="line">username=user              ; (default is no username (open server))</span><br><span class="line">password=123               ; (default is no password (open server))</span><br></pre></td></tr></table></figure><p>​    意思是将web服务页面打开，需要注意ip地址要写*，否则外网访问不了，而username和password就是登录服务页面的用户名和密码，可以改的复杂一点，另外阿里云也需要向外网暴露一下9001端口</p><p>​    然后在配置文件末尾加上tornado的配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[program:mytornado]</span><br><span class="line">command=python3 /root/mytornado/server.py --port=8001</span><br><span class="line">directory=/root/mytornado</span><br><span class="line">autorestart=true</span><br><span class="line">redirect_stderr=true</span><br></pre></td></tr></table></figure><p>​    </p><p>​    保存文件退出后，启动supervisor服务</p><p>​    </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">supervisord -c /etc/supervisord.conf</span><br></pre></td></tr></table></figure><p>​    此时，将刚刚手动启动的tornado服务关闭，然后访问服务器的9001端口，用配置文件中的账号和密码登录</p><p><img src="https://v3u.cn/v3u/Public/js/editor/attached/image/20190823/20190823024429_56609.png" alt="img"></p><p>​    这样就可以在管理页面中控制tornado服务了，同时supervisor还赋予了守护进程模式，方便服务拉起</p><p>​    需要注意的是，当修改了supervisor的配置，想要生效就得重启supervisor服务，终止服务命令是：</p><p>​    </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">killall -s INT /usr/bin/python</span><br></pre></td></tr></table></figure><p>​    因为supervisor是基于python2的，所以不用担心python3的进程</p><p>​    另外如果只想在命令行中控制tornado也是可以的</p><p>​    </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#停止tornado服务</span><br><span class="line">supervisorctl stop mytornado</span><br><span class="line"></span><br><span class="line">#启动tornado服务</span><br><span class="line">supervisorctl start mytornado</span><br></pre></td></tr></table></figure><p>至此，我们通过nginx反向代理tornado负载均衡，并且通过supervisor管理就部署好了，简直太简单了</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;​    这一次使用vue.js+tornado的组合来部署前后端分离的web项目，vue.js不用说了，前端当红炸子鸡，泛用性非常广，无论是单页应用，还是混合式开发app，亦或是微信小程序开发，样样得心应手，tornado最近的风头有点被新锐框架sanic抢走了，但是作为
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>python3.7.3操作FastDfs来进行文件操作</title>
    <link href="https://zxyyee.cn/post/python3-7-3%E6%93%8D%E4%BD%9CFastDfs%E6%9D%A5%E8%BF%9B%E8%A1%8C%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C.html"/>
    <id>https://zxyyee.cn/post/python3-7-3操作FastDfs来进行文件操作.html</id>
    <published>2019-05-17T12:56:16.000Z</published>
    <updated>2019-09-18T07:36:15.336Z</updated>
    
    <content type="html"><![CDATA[<p>在之前的一篇文章中:<a href="[http://iamhaibei.cn/2019/05/12/利用Docker来搭建分布式文件系统FastDfs/](http://yoursite.com/2019/05/12/%E5%88%A9%E7%94%A8Docker%E6%9D%A5%E6%90%AD%E5%BB%BA%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9FFastDfs/)">利用Docker来搭建分布式文件系统FastDfs</a>，我们已经搭建好了FastDfs分布式文件系统，并且已经可以通过命令进行上传操作，那么如何使用python来上传文件呢？</p><p>​    很简单，还是利用docker的特性，我们知道docker 的 -v 参数，可以自动挂载宿主机的文件件到容器中去，这样宿主和容器就可以进行无障碍的文件共享，我们通过-v参数，把宿主机的root目录自动挂载到docker容器中的/var/root目录中去。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --network=host --name tracker -v /root:/var/root delron/fastdfs tracker</span><br><span class="line"></span><br><span class="line">docker run -d --network=host --name storage -e TRACKER_SERVER=172.18.0.1:22122 -v /root:/var/root -e GROUP_NAME=group1 delron/fastdfs storage</span><br></pre></td></tr></table></figure><p>我们又起了两个服务，一个tracker(调度)另外一个是storage(仓库),只不过都共享了宿主的文件夹/root，挂载到了/var/root下</p><p>然后分别进入宿主的命令行以及进入容器storage的命令行，发现文件夹已经共享</p><p><img src="https://v3u.cn/v3u/Public/js/editor/attached/image/20190520/20190520093255_45942.png" alt="img"></p><p>此时，我们可以利用docker的exec命令不进入容器，直接在宿主机的环境下调用容器内的命令，因为文件夹已经共享，所以我们输入的文件目录虽然是容器中的/var/root目录，但是实际上该上传的文件就在宿主的/root目录中，这里，我们不上传图片，而是上传一个视频</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -i storage /usr/bin/fdfs_upload_file /etc/fdfs/client.conf /var/root/test.mp4</span><br></pre></td></tr></table></figure><p>上传成功后，fastdfs将会返回视频的网络地址</p><p><img src="https://v3u.cn/v3u/Public/js/editor/attached/image/20190520/20190520093824_83463.png" alt="img"></p><p>浏览器访问一下，没有问题</p><p><img src="https://v3u.cn/v3u/Public/js/editor/attached/image/20190520/20190520094004_88790.png" alt="img"></p><p>至此，在宿主机中上传文件已经搞定，而python同样也可以在命令行中执行命令，我们可以从命令中得到URL的做法来实现django与fastdfs的交流，这里利用的是python中的os.popen方法，可以非常简单的在命令行中获取返回的fastdfs网络地址，从而避开了必须要安装fastdfs的python客户端，因为该客户端对python3并不十分友好。代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br><span class="line">import re</span><br><span class="line"></span><br><span class="line">std = os.popen(&quot;docker exec -i storage /usr/bin/fdfs_upload_file /etc/fdfs/client.conf /var/root/test.mp4&quot;).read()</span><br><span class="line">print(&apos;*********** fastdfs excute start ***********&apos;)</span><br><span class="line">print(std.strip())</span><br><span class="line">print(&apos;*********** fastdfs excute end ***********&apos;)</span><br></pre></td></tr></table></figure><p>这样，在django中上传文件时，就可以通过命令的方式上传到fastdfs中，获取返回地址后入库就可以了，本次操作将docker的特性运用到了极致，由此可见docker的泛用性之广，实实在在的提高了开发效率。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在之前的一篇文章中:&lt;a href=&quot;[http://iamhaibei.cn/2019/05/12/利用Docker来搭建分布式文件系统FastDfs/](http://yoursite.com/2019/05/12/%E5%88%A9%E7%94%A8Docker%E6
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>利用Docker挂载Nginx-rtmp来实现实时网络直播</title>
    <link href="https://zxyyee.cn/post/%E5%88%A9%E7%94%A8Docker%E6%8C%82%E8%BD%BDNginx-rtmp%E6%9D%A5%E5%AE%9E%E7%8E%B0%E5%AE%9E%E6%97%B6%E7%BD%91%E7%BB%9C%E7%9B%B4%E6%92%AD.html"/>
    <id>https://zxyyee.cn/post/利用Docker挂载Nginx-rtmp来实现实时网络直播.html</id>
    <published>2019-05-16T02:05:40.000Z</published>
    <updated>2019-09-18T07:41:45.685Z</updated>
    
    <content type="html"><![CDATA[<h1 id="利用Docker挂载Nginx-rtmp-服务器直播流分发-FFmpeg-推流-Vue-js结合Video-js-播放器流播放-来实现实时网络直播"><a href="#利用Docker挂载Nginx-rtmp-服务器直播流分发-FFmpeg-推流-Vue-js结合Video-js-播放器流播放-来实现实时网络直播" class="headerlink" title="利用Docker挂载Nginx-rtmp(服务器直播流分发)+FFmpeg(推流)+Vue.js结合Video.js(播放器流播放)来实现实时网络直播"></a>利用Docker挂载Nginx-rtmp(服务器直播流分发)+FFmpeg(推流)+Vue.js结合Video.js(播放器流播放)来实现实时网络直播</h1><p>众所周知，在视频直播领域，有不同的商家提供各种的商业解决方案，其中比较靠谱的服务商有阿里云直播，腾讯云直播，以及又拍云和网易云的有偿直播服务，服务包括软硬件设备，摄像机，编码器，流媒体服务器等。但是其高昂的费用以及较高的准入门槛让许多个人和小型企业望而却步，本文要讲解的是如何使用nginx-rtmp搭建直播服务器，配合FFmpeg推流，在网页端vue.js作为载体利用video.js作为流播放器，打造一套可用的在线视频直播方案。</p><p>​    </p><p>​    视频直播的流程可以分为如下几步： </p><p>​    采集 —&gt;处理—&gt;编码和封装—&gt;推流到服务器—&gt;服务器流分发—&gt;播放器流播放<br>    实现直播节目在终端上的展现。因为我这里使用的传输协议是RTMP， 所以只要支持RTMP 流协议的播放器都可以使用，这里我们使用nginx,<br>    一般情况下视频采集处理后推流到流媒体服务器，第一部分功能完成。第二部分就是流媒体服务器，负责把从第一部分接收到的流进行处理并分发给观众。第三部分就是客户端播放，只需要拥有支持流传输协议的播放器即可</p><p>​    <img src="https://v3u.cn/v3u/Public/js/editor/attached/image/20190516/20190516092344_58818.jpg" alt="img"></p><p>​    搭建直播服务器是一个漫长而复杂的过程，编译设置有点繁琐。好在docker上有大把别人编译设置好的rtmp环境，所以可以直接拿来用，docker的优越性由此可见一斑，这里用到的是alfg/nginx-rtmp库。</p><p>​    </p><p>​    安装docker，可以在阿里云的镜像上下载比较快一点 <a href="http://mirrors.aliyun.com/docker-toolbox/windows/docker-toolbox/" target="_blank" rel="noopener">http://mirrors.aliyun.com/docker-toolbox/windows/docker-toolbox/</a></p><p>​    目前稳定版是DockerToolbox-18.03.0-ce.exe 直接点击安装即可</p><p>​    安装过程有一点需要注意，必须要开启本机bios的cpu虚化技术</p><p>​    安装好docker后，下载nginx-rtmp镜像，并且运行服务映射端口到1945和8000</p><p>​    </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker pull alfg/nginx-rtmp</span><br><span class="line">docker run -it -p 1935:1935 -p 8000:80 --rm alfg/nginx-rtmp</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>访问宿主的8000端口显示nginx欢迎页面</p><p><img src="https://v3u.cn/v3u/Public/js/editor/attached/image/20190516/20190516093806_13484.png" alt="img"></p><p>然后利用FFmpeg进行推流操作，ffmpeg是什么请移步：<a href="https://v3u.cn/a_id_74" target="_blank" rel="noopener">Python3利用ffmpeg针对视频进行一些操作</a></p><p>输入命令，注意摄像头和麦必须和电脑的设备吻合，另外推流服务器也要推到刚刚部署好的nginx上面去</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -f dshow -i video=&quot;VMware Virtual USB Video Device&quot;:audio=&quot;Microphone (High Definition Audio Device)&quot; -tune:v zerolatency -f flv &quot;rtmp://192.168.99.100:1935/stream/test&quot;</span><br></pre></td></tr></table></figure><p><img src="https://v3u.cn/v3u/Public/js/editor/attached/image/20190516/20190516094245_34109.png" alt="img"></p><p>​    推流成功后，我们就要在网站上观看现场直播了，这里前端服务我们使用vue.js来搭建，视频流播放器我们使用video.js</p><p>首先建立一个直播的脚手架项目，然后安装一下必要的直播库，最后启动项目</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#建立项目</span><br><span class="line">vue init webpack-simple zhibo</span><br><span class="line">cd zhibo</span><br><span class="line">cnpm install vue-router save</span><br><span class="line">cnpm install</span><br><span class="line"></span><br><span class="line">#安装直播组件</span><br><span class="line">cnpm install video.js</span><br><span class="line">cnpm install aes-decrypter</span><br><span class="line">cnpm install m3u8-parser</span><br><span class="line">cnpm install mpd-parser</span><br><span class="line">cnpm install mux.js</span><br><span class="line">cnpm install url-toolkit</span><br><span class="line">cnpm install videojs-contrib-hls</span><br><span class="line"></span><br><span class="line">#热启动项目</span><br><span class="line">cnpm run dev</span><br></pre></td></tr></table></figure><p>新建一个video.vue，添加播放代码</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">      &lt;video id="my-video" class="video-js vjs-default-skin" controls preload="auto" &gt;</span><br><span class="line">    &lt;!-- 直播地址就是nginx映射后的播放地址，注意后缀为直播流的m3u8 --&gt;</span><br><span class="line">    &lt;source src=<span class="string">"http://192.168.99.100:8000/live/test.m3u8"</span> &gt;</span><br><span class="line">&lt;/video&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/template&gt;</span><br><span class="line">   </span><br><span class="line">  &lt;script&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> videojs <span class="keyword">from</span> <span class="string">'video.js'</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'videojs-contrib-hls'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  export default &#123;</span><br><span class="line">    data () &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">      </span><br><span class="line">      &#125;</span><br><span class="line">    </span><br><span class="line">    &#125;,</span><br><span class="line">    mounted:function()&#123;</span><br><span class="line"></span><br><span class="line">      videojs(<span class="string">'my-video'</span>, &#123;</span><br><span class="line">    bigPlayButton: true,</span><br><span class="line">    textTrackDisplay: false,</span><br><span class="line">    posterImage: true,</span><br><span class="line">    errorDisplay: false,</span><br><span class="line">    controlBar: true</span><br><span class="line">&#125;, function () &#123;</span><br><span class="line">    this.play()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">   </span><br><span class="line">  &lt;style&gt;</span><br><span class="line">  &lt;/style&gt;</span><br></pre></td></tr></table></figure><p>最后，在vue.js的路由里绑定video.vue组件，进入浏览器，测试直播播放</p><p>搞定收工</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;利用Docker挂载Nginx-rtmp-服务器直播流分发-FFmpeg-推流-Vue-js结合Video-js-播放器流播放-来实现实时网络直播&quot;&gt;&lt;a href=&quot;#利用Docker挂载Nginx-rtmp-服务器直播流分发-FFmpeg-推流-Vue-js结
      
    
    </summary>
    
      <category term="nginx" scheme="https://zxyyee.cn/categories/nginx/"/>
    
    
      <category term="nginx" scheme="https://zxyyee.cn/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>利用Docker来搭建分布式文件系统FastDfs</title>
    <link href="https://zxyyee.cn/post/%E5%88%A9%E7%94%A8Docker%E6%9D%A5%E6%90%AD%E5%BB%BA%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9FFastDfs.html"/>
    <id>https://zxyyee.cn/post/利用Docker来搭建分布式文件系统FastDfs.html</id>
    <published>2019-05-12T15:18:30.000Z</published>
    <updated>2019-09-18T07:42:11.938Z</updated>
    
    <content type="html"><![CDATA[<p>对于文件存储来说，一般情况下简单的处理就是在Django配置文件中配置存储目录，按照规则对文件进行上传或者下载。</p><p>​    实际上，当文件较少的时候，Django是可以应付的过来的。但当文件以海量形式出现的时候，Django就并不是那么好用了，于是Fast DFS应运而出。<br>        FastDFS是一个开源的分布式文件系统，它对文件进行管理，功能包括：文件存储、文件同步、文件访问（文件上传、文件下载）等，解决了大容量存储和负载均衡的问题。特别适合以文件为载体的在线服务，如相册网站、视频网站等等。可以说它就是为互联网而生，为大数据而生的。<br>    FastDFS服务端有两个角色：跟踪器（tracker）和存储节点（storage）。跟踪器主要做调度工作，在访问上起负载均衡的作用。 存储节点存储文件，完成文件管理的所有功能：存储、同步和提供存取接口，FastDFS同时对文件的meta data进行管理。跟踪器和存储节点都可以由多台服务器构成。跟踪器和存储节点中的服务器均可以随时增加或下线而不会影响线上服务。其中跟踪器中的所有服务器都是对等的，可以根据服务器的压力情况随时增加或减少。</p><p>​    </p><p>​    说人话，为啥要用FastDfs:</p><p>​    1 解决海量存储，同时存储容量扩展方便。<br>    2 解决文件内容重复,如果用户上传的文件重复(文件指纹一样)，那么系统只有存储一份数据，值得一提的是，这项技术目前被广泛应用在网盘中。<br>    3 结合Nginx提高网站读取图片的效率。</p><p>​    <img src="https://v3u.cn/v3u/Public/js/editor/attached/image/20190519/20190519152124_33663.png" alt="img"></p><p>​    如果我们从头搭建fastdfs服务器那么就太low了，网上有大把的docker镜像供你选择，所以又到了利用docker优越性的时候了，首先下载fastdfs镜像</p><p>​    </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull delron/fastdfs</span><br></pre></td></tr></table></figure><p><img src="https://v3u.cn/v3u/Public/js/editor/attached/image/20190519/20190519134738_17692.png" alt="img"></p><p>区区四百多兆就承载了nginx和fastdfs服务</p><p>然后使用docker镜像构建tracker容器（跟踪服务器，起到调度的作用），这里tracker服务将会自动映射到宿主机上</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --network=host --name tracker -v /root:/var/root delron/fastdfs tracker</span><br></pre></td></tr></table></figure><p>使用docker镜像构建storage容器（存储服务器，提供容量和备份服务），这里storage容器需要依赖tracker服务，传入你的tracker服务的ip地址，端口默认是22122，ip地址也就是你宿主机的ip</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --network=host --name storage -e TRACKER_SERVER=192.168.99.100:22122 -v /root:/var/root -e GROUP_NAME=group1 delron/fastdfs storage</span><br></pre></td></tr></table></figure><p>此时，命令行输入 docker ps 就可以看到两套服务都已经启动</p><p><img src="https://v3u.cn/v3u/Public/js/editor/attached/image/20190519/20190519135541_36259.png" alt="img"></p><p>这时，进入正在后台运行的storage容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it storage /bin/bash</span><br></pre></td></tr></table></figure><p>随便下载一张图片,这个不用担心，因为在容器中如果不提交仓库的话，该图片是不会保存的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://v3u.cn/v3u/Public/images/logo.png</span><br></pre></td></tr></table></figure><p>将该图片通过命令上传到分布式系统中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/fdfs_upload_file /etc/fdfs/client.conf logo.png</span><br></pre></td></tr></table></figure><p>这时该图片已上传至文件系统，并在执行该语句后返回图片存储的网络地址</p><p><img src="https://v3u.cn/v3u/Public/js/editor/attached/image/20190519/20190519140239_88245.png" alt="img"></p><p>最后通过浏览器访问以下存储在Fastdfs的图片，这张图片是通过nginx代理的静态资源，默认nginx监听8888端口，所以需要加上端口号，如果是在阿里云上部署，则需要暴露外部端口8888</p><p><img src="https://v3u.cn/v3u/Public/js/editor/attached/image/20190519/20190519140507_13422.png" alt="img"></p><p>可以看到，没有任何问题，同理，如果是视频资源，同样可以上传到fastdfs中，搞定收工。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;对于文件存储来说，一般情况下简单的处理就是在Django配置文件中配置存储目录，按照规则对文件进行上传或者下载。&lt;/p&gt;
&lt;p&gt;​    实际上，当文件较少的时候，Django是可以应付的过来的。但当文件以海量形式出现的时候，Django就并不是那么好用了，于是Fast D
      
    
    </summary>
    
      <category term="Docker" scheme="https://zxyyee.cn/categories/Docker/"/>
    
    
      <category term="Docker" scheme="https://zxyyee.cn/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Redisearch实现全文检索</title>
    <link href="https://zxyyee.cn/post/Redisearch.html"/>
    <id>https://zxyyee.cn/post/Redisearch.html</id>
    <published>2019-05-11T08:13:24.000Z</published>
    <updated>2019-09-04T11:27:57.894Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用Redisearch实现的全文检索功能服务"><a href="#使用Redisearch实现的全文检索功能服务" class="headerlink" title="使用Redisearch实现的全文检索功能服务"></a>使用Redisearch实现的全文检索功能服务</h1><p>​    </p><p>​    首先，安装Rediseach,记住一点你本地的redis服务版本必须在4.0以上，网上一大堆编译安装的攻略，繁琐又浪费时间，所以又到了Docker登场时间了，hub上有编译好的免费镜像供我们下载</p><p>​    </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull redislabs/redisearch</span><br></pre></td></tr></table></figure><p>​    下载后，直接在后台启动服务</p><p>​    </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 6666:6379 redislabs/redisearch:latest</span><br></pre></td></tr></table></figure><p>​    此时已经有一个docker容器在后台启动了，redis服务映射到了宿主的6666端口，我们来连接一下</p><p>​    </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -h localhost -p 6666</span><br></pre></td></tr></table></figure><p>​    </p><p>​    检查 modules 是否成功加载</p><p>​    </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">localhost:6666&gt; MODULE list</span><br><span class="line">1) 1) &quot;name&quot;</span><br><span class="line">   2) &quot;ft&quot;</span><br><span class="line">   3) &quot;ver&quot;</span><br><span class="line">   4) (integer) 10405</span><br></pre></td></tr></table></figure><p>​    如果返回数组中存在 “ft” ， 则表明 redisearch 已经成功加载。</p><p>​    Redisearch 的索引概念 与elasticsearch 的 index 类似，表示某一类文档资源单元。<br>    这里我们定义了一个 SMARTX_VM 索引，其中存储的文档 包含 了 title 和 desc 两个 类型为 TEXT 的field。</p><p>​    </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FT.CREATE SMARTX_VM SCHEMA title TEXT WEIGHT 5.0 desc TEXT</span><br></pre></td></tr></table></figure><p>​    然后向刚刚创建的这条索引加一个文档</p><p>​    </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FT.ADD SMARTX_VM vm-2019082911110001 1.0 LANGUAGE &quot;chinese&quot; FIELDS title &quot;人工智能&quot; desc &quot;我在北京昌平学习人工智能&quot;</span><br></pre></td></tr></table></figure><p>​    LANGUAGE “chinese” 参数 表示 使用 中文分词器 处理文本。默认为英文</p><p>​    此时我们进行文档检索</p><p>​    </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FT.SEARCH SMARTX_VM &quot;人工智能&quot; LANGUAGE &quot;chinese&quot;</span><br></pre></td></tr></table></figure><p>​    注意检索的时候也要指定语言，这里我们用中文分词，默认的英文分词是无法检索中文的</p><p>​    在使用的过程中，发现在命令行进入redis-cli之后，无法对汉字进行编译，所以选择在可视化工具RedisDesktopManager中打开命令行，就可以解决这个问题了。</p>]]></content>
    
    <summary type="html">
    
      Redisearch的配置
    
    </summary>
    
      <category term="Redis" scheme="https://zxyyee.cn/categories/Redis/"/>
    
    
      <category term="Redis" scheme="https://zxyyee.cn/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>推荐算法的一些理解</title>
    <link href="https://zxyyee.cn/post/%E6%8E%A8%E8%8D%90%E7%AE%97%E6%B3%95%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3.html"/>
    <id>https://zxyyee.cn/post/推荐算法的一些理解.html</id>
    <published>2019-03-01T00:42:25.000Z</published>
    <updated>2019-09-18T07:52:00.030Z</updated>
    
    <content type="html"><![CDATA[<p>看到这篇文章，关于推荐算法阐述得比较清楚，现转载如下：</p><p><a href="https://blog.csdn.net/v_JULY_v/article/details/7184318" target="_blank" rel="noopener">https://blog.csdn.net/v_JULY_v/article/details/7184318</a></p><h1 id="1、推荐引擎原理"><a href="#1、推荐引擎原理" class="headerlink" title="1、推荐引擎原理"></a>1、推荐引擎原理</h1><p>推荐引擎尽最大努力的收集尽可能多的用户信息及行为，所谓广撒网，勤捕鱼，然后“特别的爱给特别的你”，最后基于相似性的基础之上持续“给力”，原理如下图所示（图引自本文的参考资料之一：探索推荐引擎内部的秘密）：</p><blockquote><p><img src="https://alvinqy.github.io/2019/03/01/recommend2/1564747993825.png" alt="1564747993825"></p></blockquote><h1 id="2、推荐引擎的分类"><a href="#2、推荐引擎的分类" class="headerlink" title="2、推荐引擎的分类"></a>2、推荐引擎的分类</h1><p>2、推荐引擎的分类<br>推荐引擎根据不同依据如下分类：</p><ol><li>根据其是不是为不同的用户推荐不同的数据，分为基于大众行为（网站管理员自行推荐，或者基于系统所有用户的反馈统计计算出的当下比较流行的物品）、及个性化推荐引擎（帮你找志同道合，趣味相投的朋友，然后在此基础上实行推荐）；</li><li>根据其数据源，分为基于人口统计学的（用户年龄或性别相同判定为相似用户）、基于内容的（物品具有相同关键词和Tag，没有考虑人为因素），以及基于协同过滤的推荐（发现物品，内容或用户的相关性推荐，分为三个子类，下文阐述）；</li><li>根据其建立方式，分为基于物品和用户本身的（用户-物品二维矩阵描述用户喜好，聚类算法）、基于关联规则的（The Apriori algorithm算法是一种最有影响的挖掘布尔关联规则频繁项集的算法）、以及基于模型的推荐（机器学习，所谓机器学习，即让计算机像人脑一样持续学习，是人工智能领域的一个子领域）。</li></ol><p>关于上述第二个分类（2、根据其数据源）中的基于协同过滤的推荐：随着Web2.0的发展，Web站点更加提倡用户参与和用户贡献，因此基于协同过滤的推荐机制应运而生。它的原理很简单，就是根据用户对物品或者信息的偏好，发现物品或者内容本身的相关性，或者是发现用户的相关性，然后再基于这些关联性进行推荐。</p><p>而基于协同过滤的推荐，又分三个子类：</p><ol><li>基于用户的推荐(通过共同口味与偏好找相似邻居用户，K-邻居算法，你朋友喜欢，你也可能喜欢)，</li><li>基于项目的推荐(发现物品之间的相似度，推荐类似的物品，你喜欢物品A，C与A相似，可能也喜欢C)，</li><li>基于模型的推荐(基于样本的用户喜好信息构造一个推荐模型，然后根据实时的用户喜好信息预测推荐)。</li></ol><p>我们看到，此协同过滤算法最大限度的利用用户之间，或物品之间的相似相关性，而后基于这些信息的基础上实行推荐。下文还会具体介绍此协同过滤。</p><p>不过一般实践中，我们通常还是把推荐引擎分两类：</p><ul><li>第一类称为协同过滤，即基于相似用户的协同过滤推荐（用户与系统或互联网交互留下的一切信息、蛛丝马迹，或用户与用户之间千丝万缕的联系），以及基于相似项目的协同过滤推荐（尽最大可能发现物品间的相似度）；</li><li>第二类便是基于内容分析的推荐（调查问卷，电子邮件，或者推荐引擎对本blog内容的分析）</li></ul><h1 id="3、新浪微博推荐机制"><a href="#3、新浪微博推荐机制" class="headerlink" title="3、新浪微博推荐机制"></a>3、新浪微博推荐机制</h1><p>在新浪微博推荐好友的机制中：1、我与A非好友，但我的好友中有不少人与A是好友，即我和A有不少共同的好友，那么系统便会把A也推荐给我（新浪称之为共同好友）；2、我关注的人中有不少人关注了B，那么系统推测我也可能会喜欢B，从而亦会把B也推荐给我（新浪称之为间接关注人）。</p><p>但新浪实际操作起来，这两种方式会搅在一起，如我关注的人中，有不少人关注了B，但事实上这关注B的不少人中有些也是我的好友。以上推荐方式，统称为基于相似用户的协同过滤推荐（无非就是找到：用户与用户之间千丝万缕的联系，或是从你的好友入手，或是从你关注的人入手）。</p><p>当然，还有一类比如人气用户推荐，便是上文所述的基于大众行为的推荐，即人云亦云、跟风。系统推测大家都喜欢的，可能你也会喜欢。如大家都知道姚晨新浪微博粉丝数量排第一，则争相关注，最终粉丝量越推越高。两种推荐方式如下图所示：</p><blockquote><blockquote><blockquote></blockquote><p><img src="https://alvinqy.github.io/2019/03/01/recommend2/1564748049609.png" alt="1564748049609"></p></blockquote></blockquote><p>不过，上述不论是基于用户的推荐方式，还是基于大众行为的推荐都并没有真正寻找到用户与用户之间共同的兴趣，偏好和口味，因为很多的时候，朋友的朋友不一定能成为你自己的朋友，且有的人清高于世，你们都追求的，我偏不屑。所以，从分析用户发表的微博的内容相关入手，找到各自共同的关注点、兴趣点才是王道。当然新浪微博最近让用户选择给自己发表的微博内容打上标签，以利于日后寻找微博内容中相关用户共同的标签tag，关键词，此种推荐方式正是基于微博内容分析的推荐。如下图：</p><blockquote><p><img src="https://alvinqy.github.io/2019/03/01/recommend2/1564748083204.png" alt="1564748083204"></p></blockquote><p>只是问题是，谁会不遗余力发完微博后，还去给它添加什么标签呢？所以，新浪微博还得努力，寻找另一种更好地分析微博内容的方式。不然系统全盘扫描海里用户的海量微博内容，则恐怕吃不消也负担不起。<br>然个人觉得倒是可以从微博关键词（标签tag云）和每个用户为自己打的标签（打着越多的共同标签可定义为相似用户）入手，如下图左右部分所示：</p><blockquote><p><img src="https://alvinqy.github.io/2019/03/01/recommend2/1564748110062.png" alt="1564748110062"></p></blockquote><p>也就是说，通过共同的好友和通过间接关注的人来定义相似用户是不靠谱的，只有通过基于微博内容的分析寻找相似用户才是可行之道，同时，更进一步，通过微博内容分析得到标签tag云后，再从中找到相同或相近的标签tag云寻找相似的用户无疑比已有推荐好友方式（通过共同的好友和通过间接关注的人来定义相似用户）更靠谱。</p><p>3.1、多种推荐方式结合</p><p>在现行的 Web 站点上的推荐往往都不是单纯只采用了某一种推荐的机制和策略，他们往往是将多个方法混合在一起，从而达到更好的推荐效果。</p><p>举个例子如Amazon中除此基于用户的推荐之外，还会用到基于内容的推荐(物品具有相同关键词和Tag)：如新产品的推荐；基于项目的协同过滤推荐(喜欢A，C与A类似，可能也喜欢C)：如捆绑销售and别人购买/浏览的商品。</p><p>总之，多种推荐方式结合，加权（用线性公式（linear formula）将几种不同的推荐按照一定权重组合起来，具体权重的值需要在测试数据集上反复实验，从而达到最好的推荐效果。）、切换、分区、分层等混合。但不论是哪种推荐方式，一般也就涵盖在上文所述的推荐方式中。</p><h1 id="4、协同过滤推荐"><a href="#4、协同过滤推荐" class="headerlink" title="4、协同过滤推荐"></a>4、协同过滤推荐</h1><p>协同过滤是利用集体智慧的一个典型方法。要理解什么是协同过滤 (Collaborative Filtering, 简称 CF)，首先想一个简单的问题，如果你现在想看个电影，但你不知道具体看哪部，你会怎么做？大部分的人会问问周围的朋友或者称之为广义上的邻居(neighborhood)，看看最近有什么好看的电影推荐，而我们一般更倾向于从口味比较类似的朋友那里得到推荐。这就是协同过滤的核心思想。如下图，你能从图中看到多少信息？</p><p><img src="https://alvinqy.github.io/2019/03/01/recommend2/1564748135637.png" alt="1564748135637"></p><p>做协同过滤推荐，一般要做好以下几个步骤：</p><p>1）若要做协同过滤，那么收集用户偏好则成了关键。可以通过用户的行为诸如评分（如不同的用户对不同的作品有不同的评分，而评分接近则意味着喜好口味相近，便可判定为相似用户），投票，转发，保存，书签，标记，评论，点击流，页面停留时间，是否购买等获得。如下面第2点所述：所有这些信息都可以数字化，如一个二维矩阵表示出来。</p><p>2）收集了用户行为数据之后，我们接下来便要对数据进行减噪与归一化操作(得到一个用户偏好的二维矩阵，一维是用户列表，另一维是物品列表，值是用户对物品的偏好，一般是 [0,1] 或者 [-1, 1] 的浮点数值)。下面再简单介绍下减噪和归一化操作：</p><ul><li>所谓减噪：用户行为数据是用户在使用应用过程中产生的，它可能存在大量的噪音和用户的误操作，我们可以通过经典的数据挖掘算法过滤掉行为数据中的噪音，这样可以是我们的分析更加精确（类似于网页的去噪处理）。</li><li>所谓归一化：将各个行为的数据统一在一个相同的取值范围中，从而使得加权求和得到的总体喜好更加精确。最简单的归一化处理，便是将各类数据除以此类中的最大值，以保证归一化后的数据取值在 [0,1] 范围中。至于所谓的加权，很好理解，因为每个人占的权值不同，类似于一场唱歌比赛中对某几个选手进行投票决定其是否晋级，观众的投票抵1分，专家评委的投票抵5分，最后得分最多的选手直接晋级。</li></ul><p>3）找到相似的用户和物品，通过什么途径找到呢？便是计算相似用户或相似物品的相似度。</p><p>4）相似度的计算有多种方法，不过都是基于向量Vector的，其实也就是计算两个向量的距离，距离越近相似度越大。在推荐中，用户-物品偏好的二维矩阵下，我们将某个或某几个用户对莫两个物品的偏好作为一个向量来计算两个物品之间的相似度，或者将两个用户对某个或某几个物品的偏好作为一个向量来计算两个用户之间的相似度。</p><p>相似度计算算法可以用于计算用户或者项目相似度。以项目相似度计算（Item Similarity Computation）为列，通性在于都是从评分矩阵中，为两个项目i，j挑选出共同的评分用户，然对这个共同用户的评分向量，进行计算相似度si,j，如下图所示，行代表用户，列代表项目(注意到是从i，j向量中抽出共有的评论，组成的一对向量，进行相似度计算)：</p><blockquote><p><img src="https://alvinqy.github.io/2019/03/01/recommend2/1564748166838.png" alt="1564748166838"></p></blockquote><p>所以说，很简单，找物品间的相似度，用户不变，找多个用户对物品的评分；找用户间的相似度，物品不变，找用户对某些个物品的评分。</p><p>5）而计算出来的这两个相似度则将作为基于用户、项目的两项协同过滤的推荐。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">常见的计算相似度的方法有：欧几里德距离，皮尔逊相关系数（如两个用户对多个电影的评分，采取皮尔逊相关系数等相关计算方法，可以抉择出他们的口味和偏好是否一致），Cosine相似度，Tanimoto系数。下面，简单介绍其中的欧几里得距离与皮尔逊相关系数：</span><br><span class="line"></span><br><span class="line">欧几里德距离（Euclidean Distance）是最初用于计算欧几里德空间中两个点的距离，假设 x，y 是 n 维空间的两个点，它们之间的欧几里德距离是：</span><br></pre></td></tr></table></figure><blockquote><blockquote></blockquote><p><img src="https://alvinqy.github.io/2019/03/01/recommend2/1564748187475.png" alt="1564748187475"></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;看到这篇文章，关于推荐算法阐述得比较清楚，现转载如下：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/v_JULY_v/article/details/7184318&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https:
      
    
    </summary>
    
      <category term="机器学习" scheme="https://zxyyee.cn/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="机器学习" scheme="https://zxyyee.cn/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
</feed>
